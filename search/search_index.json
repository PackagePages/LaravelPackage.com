{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Package Development","text":"<p>In my experience, learning to develop a package for Laravel can be quite challenging, which is why I previously wrote a blog series about that.</p> <p>Over time, I began thinking this topic deserves proper documentation, rather than a couple of posts that only cover my insights. That's where I feel this open-source documentation on Laravel Package Development will come in. I've bundled up my blog posts and expanded on a couple of more topics in separate chapters. Contributions (in the form of pull requests) are highly welcomed and appreciated. I hope this website can become a place to share knowledge on Laravel package development to help developers get a head start.</p> <p>You are highly encouraged to participate and contribute to this project. Please feel free to submit a PR, even only for a typo.</p> <p>First of all, I want to thank Marcel Pociot. His clear and structured video course encouraged me to create PHP packages myself. I can highly recommend his video course if you want to learn how to make (framework agnostic) PHP packages.</p> <p>This project was originally created by John Braun, read more about him and his work here: History of LaravelPackage.com.  Without him this website would not exist!</p> <p>\ud83d\udca1 Would you rather watch than read? The famous and reputable package builders from Spatie launched a full video course on Laravel Package Development.</p>","tags":["Laravel","PHP Package","Package Development"]},{"location":"#reasons-to-develop-a-package","title":"Reasons to Develop a Package","text":"<p>You might encounter a scenario where you want to reuse some feature(s) of your application in other applications, open-source a specific functionality or keep related code together but separate it from your main application. In those cases, it makes sense to extract parts to a package. Packages or \"libraries\" provide an easy way to add additional functionality to existing applications and focus on a single feature.</p>","tags":["Laravel","PHP Package","Package Development"]},{"location":"#companion-package","title":"Companion Package","text":"<p>In this documentation, we'll build a demo package along the way (called \"BlogPackage\") by introducing the listed functionalities one-by-one. Make sure to check out the finished version of this companion package to have a handy reference, for example, when something doesn't work as expected. The demo package contains a test suite comprising unit and feature tests for the covered topics.</p>","tags":["Laravel","PHP Package","Package Development"]},{"location":"#composer-packagist","title":"Composer &amp; Packagist","text":"<p>There are nearly 240,000 packages available on Packagist, the primary repository for PHP packages at the time of writing.</p> <p>Packages are downloaded and installed using Composer - PHP's package management system - which manages dependencies within a project.</p> <p>To install a package in your existing Laravel project, the <code>composer require &lt;vendor&gt;/&lt;package&gt;</code> command will download all necessary files into a <code>/vendor</code> directory of your project where all your third party packages live, separated by vendor name. Consequently, the content from these packages is separated from your application code, which means this particular code is maintained by someone else, most often by the creator of that package. Whenever the package needs an update, run <code>composer update</code> to get the latest (compatible) version of your packages.</p>","tags":["Laravel","PHP Package","Package Development"]},{"location":"#tools-and-helpers","title":"Tools and Helpers","text":"<p>The first chapter will address the basic structure of a package. While it is good to understand the general structure of a package, check out one of the following helpful tools to instantly set-up the basic skeleton.</p> <ul> <li> <p>Package Skeleton by Spatie   This package skeleton by Spatie offers a great starting point for setting up a Laravel package from scratch. Besides the essential components of a Laravel Package, the skeleton comes with a GitHub specific configuration including a set of (CI) workflows for GitHub actions. They also offer a skeleton for generic PHP packages.</p> </li> <li> <p>Laravel Package Boilerplate   This tool by Marcel Pociot allows you to generate a basic template for Laravel specific and generic PHP packages that can be downloaded as a <code>.zip</code> file.</p> </li> <li> <p>Laravel Packager   This package by Jeroen-G provides a CLI tool to quickly scaffold packages from within an existing Laravel application. The package was featured on Laracasts in the Building Laracasts series.</p> </li> <li> <p>Laravel Packager Hermes   This package by DelveFore is an extension of the Laravel Packager package, enabling usage of Artisan commands within that package to quickly generate Laravel specific classes. Currently, it only supports the scaffolding of <code>Controllers</code>.</p> </li> <li> <p>Orchestral Canvas   The Orchestral Canvas package offers code generators and replicates all of the <code>make</code> artisan commands available in your basic Laravel application.</p> </li> <li> <p>Yeoman Laravel Package Scaffolder   This package provides a standalone generator to quickly scaffold a Laravel package. It will generate a skeleton structure, a ready-to-go composer.json file, and a fully configured service provider. Just uncomment what you need and start developing.</p> </li> <li> <p>Laravel Packer   A PHP package offering a command-line tool to scaffold a basic package directory structure and <code>composer.json</code> file and provides the <code>make</code> artisan commands within your package.</p> </li> <li> <p>Laravel Package Maker   A PHP package that provides all the Laravel <code>make</code> commands for package development. It uses Composer's repositories feature to symlink your test app with your package to make testing as easy as possible.</p> </li> </ul>","tags":["Laravel","PHP Package","Package Development"]},{"location":"01-the-basics/","title":"The Basics","text":"","tags":["package basics","directory structure","autoloading","composer"]},{"location":"01-the-basics/#autoloading","title":"Autoloading","text":"<p>Composer will generate an <code>autoload.php</code> file in the <code>/vendor</code> directory after each installation or update. By including this single file, you\u2019ll be able to access all classes provided by your installed libraries.</p> <p>Looking at a Laravel project, you\u2019ll see that the <code>public/index.php</code> file in the application root (which handles all incoming requests) requires the autoloader, which then makes all required libraries usable within the scope of your application. This includes Laravel\u2019s first-party Illuminate components as well as any required third party packages.</p> <p>Laravel's <code>public/index.php</code> file:</p> public/index.php<pre><code>&lt;?php\n\ndefine('LARAVEL_START', microtime(true));\n\nrequire __DIR__.'/../vendor/autoload.php';\n\n// additional bootstrapping methods...\n</code></pre>","tags":["package basics","directory structure","autoloading","composer"]},{"location":"01-the-basics/#directory-structure","title":"Directory Structure","text":"<p>In general (and by convention), a package contains a <code>src/</code> (short for \u201csource\u201d) folder containing all package specific logic (classes) and a <code>composer.json</code> file containing information about the package itself. Additionally, most packages also include a license and documentation.</p> <p>If we look at the general directory structure of a generic package, you\u2019ll notice how it looks quite different from a standard Laravel project.</p> <pre><code>- src\n- tests\nCHANGELOG.md\nREADME.md\nLICENSE\ncomposer.json\n</code></pre> <p>In a package, all code that would ordinarily live in the <code>app/</code> directory of a Laravel application will live in the <code>src/</code> directory of your package.</p>","tags":["package basics","directory structure","autoloading","composer"]},{"location":"02-development-environment/","title":"Development Environment","text":"","tags":["development setup","composer","package skeleton","PSR","namespacing","testing","testbench"]},{"location":"02-development-environment/#installing-composer","title":"Installing Composer","text":"<p>There's a big chance that you already have Composer installed. However, if you haven't installed Composer already, the quickest way to get up and running is by copying the script provided on the download page of Composer. By copying and pasting the provided script in your command line, the <code>composer.phar</code> installer will be downloaded, run, and removed again. You can verify a successful installation by running <code>composer --version</code>. To update Composer to the latest version, run <code>composer self-update</code>.</p>","tags":["development setup","composer","package skeleton","PSR","namespacing","testing","testbench"]},{"location":"02-development-environment/#package-skeleton","title":"Package Skeleton","text":"<p>To start with developing a package, first, create an empty directory. It is not necessary to nest packages in an existing Laravel project. I would highly recommend organizing your packages separate from your (Laravel) projects for the sake of clarity.</p> <p>For example, I store all packages in <code>~/packages/</code> and my Laravel apps live in <code>~/websites/</code>.</p>","tags":["development setup","composer","package skeleton","PSR","namespacing","testing","testbench"]},{"location":"02-development-environment/#composerjson","title":"Composer.json","text":"<p>Let's start by creating a <code>composer.json</code> file in the root of your package directory, having a minimal configuration (as shown below). Replace all details from the example with your own.</p> <p>It is best to be consistent with naming your packages. The standard convention is to use your GitHub / Gitlab / Bitbucket / etc.` username followed by a forward-slash (\"/\") and then a kebab cased version of your package name.</p> <p>An example <code>composer.json</code> is highlighted below.</p> composer.json<pre><code>{\n  \"name\": \"johndoe/blogpackage\",\n  \"description\": \"A demo package\",\n  \"type\": \"library\",\n  \"license\": \"MIT\",\n  \"authors\": [\n    {\n      \"name\": \"John Doe\",\n      \"email\": \"john@doe.com\"\n    }\n  ],\n  \"require\": {}\n}\n</code></pre> <p>Alternatively, you can create your <code>composer.json</code> file by running <code>composer init</code> in your empty package directory.</p> <p>If you're planning to publish the package, it is important to choose an appropriate package type (in our case, a \"library\") and license (e.g., \"MIT\"). Learn more about open source licenses at ChooseALicense.com.</p>","tags":["development setup","composer","package skeleton","PSR","namespacing","testing","testbench"]},{"location":"02-development-environment/#namespacing","title":"Namespacing","text":"<p>Since we want to use the (conventional) <code>src/</code> directory to store our code, we need to tell Composer to map the package's namespace to that specific directory when creating the autoloader (<code>vendor/autoload.php</code>).</p> <p>We can register our namespace under the \"psr-4\" autoload key in the <code>composer.json</code> file as follows (replace the namespace with your own):</p> composer.json<pre><code>{\n  ...,\n\n  \"require\": {},\n\n  \"autoload\": {\n    \"psr-4\": {\n      \"JohnDoe\\\\BlogPackage\\\\\": \"src\"\n    }\n  }\n}\n</code></pre>","tags":["development setup","composer","package skeleton","PSR","namespacing","testing","testbench"]},{"location":"02-development-environment/#psr-4-autoloading","title":"PSR-4 Autoloading","text":"<p>Now, you might wonder why we needed a \"psr-4\" key. PSR stands for PHP Standards Recommendations devised by the PHP Framework Interoperability Group (PHP-FIG). This group of 20 members, representing a cross-section of the PHP community, proposed a series of PSR's.</p> <p>In the list, PSR-4 represents a recommendation regarding autoloading classes from file paths, replacing the until then prevailing PSR-0 autoloading standard.</p> <p>The significant difference between PSR-0 and PSR-4 is that PSR-4 allows to map a base directory to a particular namespace and therefore permits shorter namespaces. I think this comment on StackOverflow has a clear description of how PSR-0 and PSR-4 work.</p> <p>PSR-0</p> <pre><code>\"autoload\": {\n    \"psr-0\": {\n        \"Book\\\\\": \"src/\",\n        \"Vehicle\\\\\": \"src/\"\n    }\n}\n</code></pre> <ul> <li> <p>Looking for <code>Book\\History\\UnitedStates</code> in <code>src/Book/History/UnitedStates.php</code></p> </li> <li> <p>Looking for <code>Vehicle\\Air\\Wings\\Airplane</code> in <code>src/Vehicle/Air/Wings/Airplane.php</code></p> </li> </ul> <p>PSR-4</p> <pre><code>\"autoload\": {\n    \"psr-4\": {\n        \"Book\\\\\": \"src/\",\n        \"Vehicle\\\\\": \"src/\"\n    }\n}\n</code></pre> <ul> <li> <p>Looking for <code>Book\\History\\UnitedStates</code> in <code>src/History/UnitedStates.php</code></p> </li> <li> <p>Looking for <code>Vehicle\\Air\\Wings\\Airplane</code> in <code>src/Air/Wings/Airplane.php</code></p> </li> </ul>","tags":["development setup","composer","package skeleton","PSR","namespacing","testing","testbench"]},{"location":"02-development-environment/#importing-the-package-locally","title":"Importing the Package Locally","text":"<p>To help with development, you can require a local package in a local Laravel project.</p> <p>If you have a local Laravel project, you can require your package locally by defining a custom so-called \"repository\" in the <code>composer.json</code> file of your Laravel application.</p> <p>Add the following \"repositories\" key below the \"scripts\" section in <code>composer.json</code> file of your Laravel app (replace the \"url\" with the directory where your package lives):</p> composer.json<pre><code>{\n  \"scripts\": { ... },\n\n  \"repositories\": [\n    {\n      \"type\": \"path\",\n      \"url\": \"../../packages/blogpackage\"\n    }\n  ]\n}\n</code></pre> <p>You can now require your local package in the Laravel application using your chosen namespace of the package. Following our example, this would be:</p> <pre><code>composer require johndoe/blogpackage\n</code></pre> <p>Note: This documentation assumes you are using Laravel 8.0. If you are using Laravel 10, the above command will throw a <code>minimum stability constraint</code> error. You can fix the issue by adding the <code>version</code> key below the <code>name</code> key  in the <code>composer.json</code> file of the package.</p> composer.json<pre><code>{\n  \"version\": \"1.0.0\",\n}\n</code></pre> <p>By default, the package is added under <code>vendor</code> folder as a symlink if possible. If you would like to make a physical copy instead (i.e. mirroring), add the field <code>\"symlink\": false</code> to the repository definition's <code>options</code> property:</p> composer.json<pre><code>{\n  \"scripts\": { ... },\n\n  \"repositories\": [\n    {\n      \"type\": \"path\",\n      \"url\": \"../../packages/blogpackage\",\n      \"options\": {\n        \"symlink\": false\n      }\n    }\n  ]\n}\n</code></pre> <p>If you have multiple packages in the same directory and want to instruct Composer to look for all of them, you can list the package location by using a wildcard <code>*</code> as follows:</p> composer.json<pre><code>{\n  \"scripts\": { ... },\n\n  \"repositories\": [\n    {\n      \"type\": \"path\",\n      \"url\": \"../../packages/*\"\n    }\n  ]\n}\n</code></pre> <p>Important: you will need to perform a composer update in your Laravel application whenever you make changes to the <code>composer.json</code> file of your package or any providers it registers.</p>","tags":["development setup","composer","package skeleton","PSR","namespacing","testing","testbench"]},{"location":"02-development-environment/#orchestra-testbench","title":"Orchestra Testbench","text":"<p>We now have a <code>composer.json</code> file and an empty src/ directory. However, we don't have access to any Laravel specific functionality provided by the <code>Illuminate</code> components.</p> <p>To use these components in our package, we'll require the Orchestra Testbench. Note that each version of the Laravel framework has a corresponding version of Orchestra Testbench. In this section, I'll assume we're developing a package for Laravel 8.0, which is the latest version at the moment of writing this section.</p> <pre><code>composer require --dev \"orchestra/testbench=^6.0\"\n</code></pre> <p>The full compatibility table of the Orchestra Testbench is shown below, taken from the original documentation.</p> Laravel Testbench 11.x 9.x 10.x 8.x 9.x 7.x 8.x 6.x 7.x 5.x 6.x 4.x 5.x.x 3.x.x <p>With Orchestra Testbench installed, you'll find a <code>vendor/orchestra/testbench-core</code> directory, containing a <code>laravel</code> and <code>src</code> directory. The <code>laravel</code> directory resembles the structure of an actual Laravel application, and the <code>src</code> directory provides the Laravel helpers that involve interaction with the project's directory structure (for example, related to file manipulation).</p> <p>Before each test, TestBench creates a testing environment including a fully booted (test) application. If we use the Orchestra TestBench's basic <code>TestCase</code> for our tests, the methods as provided by the <code>CreatesApplication</code> trait in the <code>Orchestra\\Testbench\\Concerns</code> namespace will be responsible for creating this test application. If we look at one of these methods, <code>getBasePath()</code>, we'll see it directly points to the <code>laravel</code> folder that comes with Orchestra Testbench.</p> vendor/orchestra/testbench-core/src/Concerns/CreatesApplication.php<pre><code>&lt;?php\n\n/**\n * Get base path.\n *\n * @return string\n */\nprotected function getBasePath()\n{\n    return \\realpath(__DIR__.'/../../laravel');\n}\n</code></pre>","tags":["development setup","composer","package skeleton","PSR","namespacing","testing","testbench"]},{"location":"03-service-providers/","title":"Service Providers","text":"<p>An essential part of a package is its Service Provider. Before creating our own, I'll explain what service providers are about in this section first. If you are familiar with service providers, please continue to the next section.</p> <p>As you might know, Laravel comes with a series of service providers, namely the <code>AppServiceProvider</code>, <code>AuthServiceProvider</code>, <code>BroadcastServiceProvider</code>, <code>EventServiceProvider</code> and <code>RouteServiceProvider</code>. These providers take care of \"bootstrapping\" (or \"registering\") application-specific services (as service container bindings), event listeners, middleware, and routes.</p> <p>Every service provider extends the <code>Illuminate\\Support\\ServiceProvider</code> and implements a <code>register()</code> and a <code>boot()</code> method.</p> <p>The <code>boot()</code> method is used to bind things in the service container. After all other service providers have been registered (i.e., all <code>register()</code> methods of all service providers were called, including third-party packages), Laravel will call the boot() method on all service providers.</p> <p>In the <code>register()</code> method, you might register a class binding in the service container, enabling a class to be resolved from the container. However, sometimes you will need to reference another class, in which case the <code>boot()</code> method can be used.</p> <p>Here is an example of how a service provider may look and which things you might implement in a <code>register()</code> and <code>boot()</code> method.</p> <pre><code>&lt;?php\n\nuse App\\Calculator;\nuse Illuminate\\Support\\Collection;\nuse Illuminate\\Support\\Facades\\Gate;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass AppServiceProvider extends ServiceProvider\n{\n  public function register()\n  {\n    // Register a class in the service container\n    $this-&gt;app-&gt;bind('calculator', function ($app) {\n      return new Calculator();\n    });\n  }\n\n  public function boot()\n  {\n    // Register a macro, extending the Illuminate\\Collection class\n    Collection::macro('rejectEmptyFields', function () {\n      return $this-&gt;reject(function ($entry) {\n        return $entry === null;\n       });\n    });\n\n    // Register an authorization policy\n    Gate::define('delete-post', function ($user, $post) {\n      return $user-&gt;is($post-&gt;author);\n    });\n  }\n}\n</code></pre>","tags":["Service Provider"]},{"location":"03-service-providers/#creating-a-service-provider","title":"Creating a Service Provider","text":"<p>We will create a service provider for our package, which contains specific information about our package's core. The package might use a config file, maybe some views, routes, controllers, database migrations, model factories, custom commands, etc. The service provider needs to register them. We will discuss each of these in subsequent chapters.</p> <p>Since we've pulled in Orchestra Testbench, we can extend the <code>Illuminate\\Support\\ServiceProvider</code> and create our service provider in the <code>src/</code> directory as shown (replace naming with your details):</p> src/BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage;\n\nuse Illuminate\\Support\\ServiceProvider;\n\nclass BlogPackageServiceProvider extends ServiceProvider\n{\n  public function register()\n  {\n    //\n  }\n\n  public function boot()\n  {\n    //\n  }\n}\n</code></pre>","tags":["Service Provider"]},{"location":"03-service-providers/#autoloading","title":"Autoloading","text":"<p>To automatically register it with a Laravel project using Laravel's package auto-discovery we add our service provider to the \"extra\"&gt; \"laravel\"&gt; \"providers\" key in our package's <code>composer.json</code>:</p> composer.json<pre><code>{\n  ...,\n\n  \"autoload\": { ... },\n\n  \"extra\": {\n      \"laravel\": {\n          \"providers\": [\n              \"JohnDoe\\\\BlogPackage\\\\BlogPackageServiceProvider\"\n          ]\n      }\n  }\n}\n</code></pre> <p>Now, whenever someone includes our package, the service provider will be loaded, and everything we've registered will be available in the application. Now let's see what we might want to register in this service provider.</p> <p>Important: this feature is available starting from Laravel 5.5. With version 5.4 or below, you must register your service providers manually in the providers section of the <code>config/app.php</code> configuration file in your laravel project.</p> config/app.php<pre><code>&lt;?php\n\n'providers' =&gt; [\n    // Other Service Providers\n\n    App\\Providers\\ComposerServiceProvider::class,\n],\n</code></pre>","tags":["Service Provider"]},{"location":"04-testing/","title":"Testing","text":"<p>It is essential to have proper test coverage for the package's provided code. Adding tests to our package can confirm the existing code's behavior, verify everything still works whenever adding new functionality, and ensure we can safely refactor our package with confidence at a later stage.</p> <p>Additionally, having good code coverage can motivate potential contributors by giving them more confidence that their addition does not break something else in the package. Tests also allow other developers to understand how specific features of your package are to be used and give them confidence about your package's reliability.</p>","tags":["Testing","PHPUnit","Directory Structure"]},{"location":"04-testing/#installing-phpunit","title":"Installing PHPUnit","text":"<p>There are many options to test behavior in PHP, Laravel is built with testing in mind and provides support for testing with Pest and PHPUnit. We can install PHPUnit, which is the default testing framework for Laravel.</p> <p>Install PHPUnit as a dev-dependency in our package:</p> <pre><code>composer require --dev phpunit/phpunit\n</code></pre>","tags":["Testing","PHPUnit","Directory Structure"]},{"location":"04-testing/#installing-pest","title":"Installing Pest","text":"<p>Alternatively, we can use Pest as our testing framework. It's important to note that Pest is built on top of PHPUnit, which means that all the options offered by PHPUnit can also be used in Pest. Therefore, our configurations for PHPUnit will also apply to Pest tests.</p> <p>Install Pest as a dev-dependency in our package and initialize it:</p> <pre><code>composer require --dev pestphp/pest\n\n./vendor/bin/pest --init\n</code></pre> <p>The <code>--init</code> flag will create a <code>tests</code> directory with example tests, a <code>TestCase.php</code> file and a <code>Pest.php</code> file. It will also create a <code>phpunit.xml</code> file with the necessary configurations for Pest, this saves us from having to create these files manually.</p> <p>In the <code>Pest.php</code> file, we can uncomment the <code>uses</code> method and add the <code>TestCase</code> class to the <code>uses</code> method. This will allow us to use the <code>TestCase</code> class in our tests.</p> tests/Pest.php<pre><code>&lt;?php\n\n...\n\nuses(JohnDoe\\BlogPackage\\Tests\\TestCase::class)-&gt;in('Feature');\nuses(JohnDoe\\BlogPackage\\Tests\\TestCase::class)-&gt;in('Unit');\n\n...\n</code></pre> <p>Note: you might need to install a specific version if you're developing a package for an older version of Laravel. Also to install <code>orchestra/testbench</code>, please refer to Orchestra Testbench set up on the Development Environment page.</p> <p>To configure PHPUnit, create a <code>phpunit.xml</code> file in the root directory of the package. Then, copy the following template to use an in-memory sqlite database and enable colorful reporting.</p> <p><code>phpunit.xml</code>:</p> phpunit.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;phpunit\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n     bootstrap=\"vendor/autoload.php\"\n     backupGlobals=\"false\"\n     colors=\"true\"\n     processIsolation=\"false\"\n     stopOnFailure=\"false\"\n     xsi:noNamespaceSchemaLocation=\"https://schema.phpunit.de/10.1/phpunit.xsd\"\n     cacheDirectory=\".phpunit.cache\"\n     backupStaticProperties=\"false\"\n&gt;\n  &lt;coverage/&gt;\n  &lt;testsuites&gt;\n    &lt;testsuite name=\"Unit\"&gt;\n      &lt;directory suffix=\"Test.php\"&gt;./tests/Unit&lt;/directory&gt;\n    &lt;/testsuite&gt;\n    &lt;testsuite name=\"Feature\"&gt;\n      &lt;directory suffix=\"Test.php\"&gt;./tests/Feature&lt;/directory&gt;\n    &lt;/testsuite&gt;\n  &lt;/testsuites&gt;\n  &lt;php&gt;\n    &lt;env name=\"DB_CONNECTION\" value=\"testing\"/&gt;\n    &lt;env name=\"APP_KEY\" value=\"base64:2fl+Ktvkfl+Fuz4Qp/A75G2RTiWVA/ZoKZvp6fiiM10=\"/&gt;\n  &lt;/php&gt;\n  &lt;source&gt;\n    &lt;include&gt;\n      &lt;directory suffix=\".php\"&gt;src/&lt;/directory&gt;\n    &lt;/include&gt;\n  &lt;/source&gt;\n&lt;/phpunit&gt;\n</code></pre> <p>Note the dummy <code>APP_KEY</code> in the example above. This environment variable is consumed by Laravel's encrypter, which your tests might be making use of. For most cases, the dummy value will be sufficient. However, you are free to either change this value to reflect an actual app key (of your Laravel application) or leave it off entirely if your test suite does not interact with the encrypter.</p>","tags":["Testing","PHPUnit","Directory Structure"]},{"location":"04-testing/#directory-structure","title":"Directory Structure","text":"<p>To accommodate Feature and Unit tests, create a <code>tests/</code> directory with a <code>Unit</code> and <code>Feature</code> subdirectory and a base <code>TestCase.php</code> file. The structure looks as follows:</p> <pre><code>- tests\n    - Feature\n    - Unit\n      TestCase.php\n</code></pre> <p>The <code>TestCase.php</code> extends <code>\\Orchestra\\Testbench\\TestCase</code> (see example below) and contains tasks related to setting up our \u201cworld\u201d before each test is executed. In the <code>TestCase</code> class we will implement three important set-up methods: <code>setUp()</code>, <code>getEnvironmentSetUp()</code> and <code>getPackageProviders()</code>.</p> <p>Let's look at these methods one by one:</p> <ul> <li> <p><code>setUp()</code>: You might have already used this method in your tests. Often it is used when you need a certain model in all following tests. The instantiation of that model can therefore be extracted to a <code>setUp()</code> method which is called before each test. Within the tests, the desired model can be retrieved from the Test class instance variable. When using this method, don't forget to call the parent <code>setUp()</code> method (and make sure to return void).</p> </li> <li> <p><code>getEnvironmentSetUp()</code>: As suggested by Orchestra Testbench: \"If you need to add something early in the application bootstrapping process, you could use the <code>getEnvironmentSetUp()</code> method\". Therefore, I suggest it is called before the <code>setUp()</code> method(s).</p> </li> <li> <p><code>getPackageProviders()</code>: As the name suggests, we can load our service provider(s) within the <code>getPackageProviders()</code> method. We'll do that by returning an array containing all providers. For now, we'll just include the package specific package provider, but imagine that if the package uses an <code>EventServiceProvider</code>, we would also register it here.</p> </li> </ul> <p>In a package, <code>TestCase</code> will inherit from the Orchestra Testbench TestCase:</p> <pre><code>// 'tests/TestCase.php'\n&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests;\n\nuse JohnDoe\\BlogPackage\\BlogPackageServiceProvider;\n\nclass TestCase extends \\Orchestra\\Testbench\\TestCase\n{\n  public function setUp(): void\n  {\n    parent::setUp();\n    // additional setup\n  }\n\n  protected function getPackageProviders($app)\n  {\n    return [\n      BlogPackageServiceProvider::class,\n    ];\n  }\n\n  protected function getEnvironmentSetUp($app)\n  {\n    // perform environment setup\n  }\n}\n</code></pre> <p>Before we can run the PHPUnit test suite, we first need to map our testing namespace to the appropriate folder in the composer.json file under an \"autoload-dev\" (psr-4) key:</p> <pre><code>{\n  ...,\n\n  \"autoload\": {},\n\n  \"autoload-dev\": {\n    \"psr-4\": {\n      \"JohnDoe\\\\BlogPackage\\\\Tests\\\\\": \"tests\"\n    }\n  }\n}\n</code></pre> <p>Finally, re-render the autoload file by running <code>composer dump-autoload</code>.</p>","tags":["Testing","PHPUnit","Directory Structure"]},{"location":"04-testing/#authentication","title":"Authentication","text":"<p>In some cases you might want to use Laravel's <code>User::class</code> to be able to use an authenticated user in your tests. There are several approaches, as discussed in the Models related to App\\User section. However, if you don't have any relationships with the <code>User</code> model, and only want to test authentication logic, the easiest option is to create your own <code>User</code> class, extending the <code>Illuminate\\Foundation\\Auth\\User</code> class:</p> App/Models/User.php<pre><code>&lt;?php\n\nuse Illuminate\\Foundation\\Auth\\User as BaseUser;\n\nclass User extends BaseUser\n{\n    protected $table = 'users';\n}\n</code></pre> <p>After defining this custom <code>User</code> model within your package, you should execute the migrate command from the <code>Orchestra</code> package to create the <code>users</code> table in your test database:</p> <pre><code>&lt;?php\n\n$this-&gt;loadLaravelMigrations(['--database' =&gt; 'testbench']);\n$this-&gt;artisan('migrate', ['--database' =&gt; 'testbench'])-&gt;run();\n</code></pre> <p>Finally, you can use the package's <code>User::class</code> in your tests within the <code>$this-&gt;actingAs()</code> helper and send a request by an authenticated user.</p>","tags":["Testing","PHPUnit","Directory Structure"]},{"location":"05-facades/","title":"Facades","text":"<p>The word 'facade' refers to a \"superficial appearance or illusion of something,\" according to Dictionary.com. In architecture, the term refers to the front of a building.</p> <p>A facade in Laravel is a class that redirects static method calls to the dynamic methods of an underlying class. A facade's goal is to provide a memorable and expressive syntax to access an underlying class's functionality.</p> <p>An example of a fluent API using a facade:</p> <pre><code>&lt;?php\n\nMessageFactory::sentBy($user)\n    -&gt;withTopic('Example message')\n    -&gt;withMessage($body)\n    -&gt;withReply($replyByFrank)\n    -&gt;create();\n</code></pre>","tags":["Facades","API"]},{"location":"05-facades/#how-a-facade-works","title":"How a Facade Works","text":"<p>To learn more about facades and how they work, refer to the excellent Laravel documentation.</p> <p>Practically, it boils down to calling static methods on a Facade, which are \"proxied\" (redirected) to the non-static methods of an underlying class you have specified. This means that you're not actually using static methods. An example is discussed below, using a <code>Calculator</code> class as an example.</p>","tags":["Facades","API"]},{"location":"05-facades/#creating-a-facade","title":"Creating a Facade","text":"<p>Let\u2019s assume that we provide a <code>Calculator</code> class as part of our package and want to make this class available as a facade.</p> <p>First create a <code>Calculator.php</code> file in the <code>src/</code> directory. To keep things simple, the calculator provides an <code>add()</code>, <code>subtract()</code> and <code>clear()</code> method. All methods return the object itself allowing for a fluent API (chaining the method calls, like: <code>-&gt;add()-&gt;subtract()-&gt;subtract()-&gt;getResult()</code>).</p> src/Calculator.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage;\n\nclass Calculator\n{\n    private $result;\n\n    public function __construct()\n    {\n        $this-&gt;result = 0;\n    }\n\n    public function add(int $value)\n    {\n        $this-&gt;result += $value;\n\n        return $this;\n    }\n\n    public function subtract(int $value)\n    {\n        $this-&gt;result -= $value;\n\n        return $this;\n    }\n\n    public function clear()\n    {\n      $this-&gt;result = 0;\n\n      return $this;\n    }\n\n    public function getResult()\n    {\n        return $this-&gt;result;\n    }\n}\n</code></pre> <p>In addition to this class, we\u2019ll create the facade in a new <code>src/Facades</code> folder:</p> src/Facades/Calculator.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Facades;\n\nuse Illuminate\\Support\\Facades\\Facade;\n\nclass Calculator extends Facade\n{\n    protected static function getFacadeAccessor()\n    {\n        return 'calculator';\n    }\n}\n</code></pre> <p>Finally, we register the binding in the service container in our service provider:</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\npublic function register()\n{\n  $this-&gt;app-&gt;bind('calculator', function($app) {\n      return new Calculator();\n  });\n}\n</code></pre> <p>The end user can now use the <code>Calculator</code> facade after importing it from the appropriate namespace: <code>use JohnDoe\\BlogPackage\\Facades\\Calculator;</code>. However, Laravel allows us to register an alias that can register a facade in the root namespace. We can define our alias under an \u201calias\u201d key below the \u201cproviders\u201d in the <code>composer.json</code> file:</p> composer.json<pre><code>\"extra\": {\n    \"laravel\": {\n        \"providers\": [\n            \"JohnDoe\\\\BlogPackage\\\\BlogPackageServiceProvider\"\n        ],\n        \"aliases\": {\n            \"Calculator\": \"JohnDoe\\\\BlogPackage\\\\Facades\\\\Calculator\"\n        }\n    }\n}\n</code></pre> <p>Important: this feature is available starting from Laravel 5.5. With version 5.4 or below, you must register your facades manually in the aliases section of the <code>config/app.php</code> configuration file.</p> <p>You can also load an alias from a Service Provider (or anywhere else) by using the <code>AliasLoader</code> singleton class:</p> <pre><code>&lt;?php\n\n$loader = \\Illuminate\\Foundation\\AliasLoader::getInstance();\n$loader-&gt;alias('Calculator', \"JohnDoe\\\\BlogPackage\\\\Facades\\\\Calculator\");\n</code></pre> <p>Our facade now no longer requires an import and can be used in projects from the root namespace:</p> <pre><code>&lt;?php\n\n// Usage of the example Calculator facade\nCalculator::add(5)-&gt;subtract(3)-&gt;getResult(); // 2\n</code></pre>","tags":["Facades","API"]},{"location":"06-artisan-commands/","title":"Artisan Commands","text":"<p>Laravel ships with an executable <code>artisan</code> file, which offers a number of helpful commands through a command-line interface (CLI).</p> <p>Via this CLI, you can access commands as <code>php artisan migrate</code> and <code>php artisan make:model Post</code>. There are a lot of things you could do with commands. Make sure to read up on the artisan console in the Laravel documentation.</p> <p>Let's say that we want to provide an easy artisan command for our end user to publish the config file, via: <code>php artisan blogpackage:install</code>.</p>","tags":["Artisan","Commands","Testing Commands","Test-Only Commands"]},{"location":"06-artisan-commands/#creating-a-new-command","title":"Creating a new Command","text":"<p>Create a new <code>Console</code> folder in the <code>src/</code> directory and create a new file named <code>InstallBlogPackage.php</code>. This class will extend Laravel's <code>Command</code> class and provide a <code>$signature</code> (the command) and a <code>$description</code> property. In the <code>handle()</code> method, we specify what our command will do. In this case we provide some feedback that we're \"installing\" the package, and we'll call another artisan command to publish the config file. Using the <code>File</code> facade we can check if the configuration file already exists. If so, we'll ask if we should overwrite it or cancel publishing of the config file. Finally, we let the user know that we're done.</p> src/Console/InstallBlogPackage.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Console;\n\nuse Illuminate\\Console\\Command;\nuse Illuminate\\Support\\Facades\\File;\n\nclass InstallBlogPackage extends Command\n{\n    protected $signature = 'blogpackage:install';\n\n    protected $description = 'Install the BlogPackage';\n\n    public function handle()\n    {\n        $this-&gt;info('Installing BlogPackage...');\n\n        $this-&gt;info('Publishing configuration...');\n\n        if (! $this-&gt;configExists('blogpackage.php')) {\n            $this-&gt;publishConfiguration();\n            $this-&gt;info('Published configuration');\n        } else {\n            if ($this-&gt;shouldOverwriteConfig()) {\n                $this-&gt;info('Overwriting configuration file...');\n                $this-&gt;publishConfiguration($force = true);\n            } else {\n                $this-&gt;info('Existing configuration was not overwritten');\n            }\n        }\n\n        $this-&gt;info('Installed BlogPackage');\n    }\n\n    private function configExists($fileName)\n    {\n        return File::exists(config_path($fileName));\n    }\n\n    private function shouldOverwriteConfig()\n    {\n        return $this-&gt;confirm(\n            'Config file already exists. Do you want to overwrite it?',\n            false\n        );\n    }\n\n    private function publishConfiguration($forcePublish = false)\n    {\n        $params = [\n            '--provider' =&gt; \"JohnDoe\\BlogPackage\\BlogPackageServiceProvider\",\n            '--tag' =&gt; \"config\"\n        ];\n\n        if ($forcePublish === true) {\n            $params['--force'] = true;\n        }\n\n       $this-&gt;call('vendor:publish', $params);\n    }\n}\n</code></pre>","tags":["Artisan","Commands","Testing Commands","Test-Only Commands"]},{"location":"06-artisan-commands/#registering-a-command-in-the-service-provider","title":"Registering a Command in the Service Provider","text":"<p>We need to present this package functionality to the end-user, thus registering it in the package's service provider.</p> <p>Since we only want to provide this functionality when used from the command-line we'll add it within a conditional which checks if the application instance is running in the console:</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nuse JohnDoe\\BlogPackage\\Console\\InstallBlogPackage;\n\npublic function boot()\n{\n    // Register the command if we are using the application via the CLI\n    if ($this-&gt;app-&gt;runningInConsole()) {\n        $this-&gt;commands([\n            InstallBlogPackage::class,\n        ]);\n    }\n}\n</code></pre>","tags":["Artisan","Commands","Testing Commands","Test-Only Commands"]},{"location":"06-artisan-commands/#scheduling-a-command-in-the-service-provider","title":"Scheduling a Command in the Service Provider","text":"<p>If you want to schedule a command from your package instead of <code>app/Console/Kernel.php</code>, inside your service provider, you need to wait until after the Application has booted and the Schedule instance has been defined:</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nuse Illuminate\\Console\\Scheduling\\Schedule;\n\npublic function boot()\n{\n    // Schedule the command if we are using the application via the CLI\n    if ($this-&gt;app-&gt;runningInConsole()) {\n        $this-&gt;app-&gt;booted(function () {\n            $schedule = $this-&gt;app-&gt;make(Schedule::class);\n            $schedule-&gt;command('some:command')-&gt;everyMinute();\n        });\n    }\n}\n</code></pre>","tags":["Artisan","Commands","Testing Commands","Test-Only Commands"]},{"location":"06-artisan-commands/#testing-a-command","title":"Testing a Command","text":"<p>To test that our Command class works, let's create a new unit test called <code>InstallBlogPackageTest.php</code> in the Unit test folder.</p> <p>Since we're using Orchestra Testbench, we have a config folder at <code>config_path()</code> containing every file a typical Laravel installation would have. (You can check where this directory lives yourself if you <code>dd(config_path()))</code>. Therefore, we can easily assert that this directory should have our <code>blogpackage.php</code> config file after running our artisan command. To ensure we're starting clean, let's delete any remainder configuration file from the previous test first.</p> tests/Unit/InstallBlogPackageTest.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests\\Unit;\n\nuse Illuminate\\Support\\Facades\\Artisan;\nuse Illuminate\\Support\\Facades\\File;\nuse JohnDoe\\BlogPackage\\Tests\\TestCase;\n\nclass InstallBlogPackageTest extends TestCase\n{\n    /** @test */\n    function the_install_command_copies_the_configuration()\n    {\n        // make sure we're starting from a clean state\n        if (File::exists(config_path('blogpackage.php'))) {\n            unlink(config_path('blogpackage.php'));\n        }\n\n        $this-&gt;assertFalse(File::exists(config_path('blogpackage.php')));\n\n        Artisan::call('blogpackage:install');\n\n        $this-&gt;assertTrue(File::exists(config_path('blogpackage.php')));\n    }\n}\n</code></pre> <p>In addition to the basic test which asserts that a configuration file is present after installation, we can add several tests which assert the appropriate installation process of our package. Let's add tests for the other scenarios where the user already has a configuration with the name <code>blogpackage.php</code> published. We will utilize the assertions <code>expectsQuestion</code>, <code>expectsOutput</code>, <code>doesntExpectOutput</code>, and <code>assertExitCode</code>.</p> tests/Unit/InstallBlogPackageTest.php<pre><code>&lt;?php\n\n/** @test */\npublic function when_a_config_file_is_present_users_can_choose_to_not_overwrite_it()\n{\n    // Given we have already have an existing config file\n    File::put(config_path('blogpackage.php'), 'test contents');\n    $this-&gt;assertTrue(File::exists(config_path('blogpackage.php')));\n\n    // When we run the install command\n    $command = $this-&gt;artisan('blogpackage:install');\n\n    // We expect a warning that our configuration file exists\n    $command-&gt;expectsConfirmation(\n        'Config file already exists. Do you want to overwrite it?',\n        // When answered with \"no\"\n        'no'\n    );\n\n    // We should see a message that our file was not overwritten\n    $command-&gt;expectsOutput('Existing configuration was not overwritten');\n\n    // Assert that the original contents of the config file remain\n    $this-&gt;assertEquals('test contents', file_get_contents(config_path('blogpackage.php')));\n\n    // Clean up\n    unlink(config_path('blogpackage.php'));\n}\n\n/** @test */\npublic function when_a_config_file_is_present_users_can_choose_to_do_overwrite_it()\n{\n    // Given we have already have an existing config file\n    File::put(config_path('blogpackage.php'), 'test contents');\n    $this-&gt;assertTrue(File::exists(config_path('blogpackage.php')));\n\n    // When we run the install command\n    $command = $this-&gt;artisan('blogpackage:install');\n\n    // We expect a warning that our configuration file exists\n    $command-&gt;expectsConfirmation(\n        'Config file already exists. Do you want to overwrite it?',\n        // When answered with \"yes\"\n        'yes'\n    );\n\n    // execute the command to force override \n    $command-&gt;execute();\n\n    $command-&gt;expectsOutput('Overwriting configuration file...');\n\n    // Assert that the original contents are overwritten\n    $this-&gt;assertEquals(\n        file_get_contents(__DIR__.'/../config/config.php'),\n        file_get_contents(config_path('blogpackage.php'))\n    );\n\n    // Clean up\n    unlink(config_path('blogpackage.php'));\n}\n</code></pre>","tags":["Artisan","Commands","Testing Commands","Test-Only Commands"]},{"location":"06-artisan-commands/#hiding-a-command","title":"Hiding a Command","text":"<p>There might be cases where you'd like to exclude the command from the list of Artisan commands. You can define a <code>$hidden</code> property on the command class, which will not show the specific command in the list of Artisan commands. NB: you can still use the command while hidden.</p> <pre><code>&lt;?php\n\nclass InstallBlogPackage extends Command\n{\n    protected $hidden = true;\n\n    protected $signature = 'blogpackage:install';\n\n    protected $description = 'Install the BlogPackage';\n\n    public function handle()\n    {\n        // ...\n    }\n}\n</code></pre>","tags":["Artisan","Commands","Testing Commands","Test-Only Commands"]},{"location":"06-artisan-commands/#creating-a-generator-command","title":"Creating a Generator Command","text":"<p>Laravel provides an easy way to create Generator Commands, i.e., commands with signatures such as <code>php artisan make:controller</code>. Those commands modify a general, predefined template (stub) to a specific application. For example, by automatically injecting the correct namespace.</p> <p>To create a Generator Command, you have to extend the <code>Illuminate\\Console\\GeneratorCommand</code> class, and override the following properties and methods:</p> <ul> <li><code>protected $name</code>: name of the command</li> <li><code>protected $description</code>: description of the command</li> <li><code>protected $type</code>: the type of class the command generates</li> <li><code>protected function getStub()</code>: method returning the path of the stub template file</li> <li><code>protected function getDefaultNamespace($rootNamespace)</code>: the default namespace of the generated class</li> <li><code>public function handle()</code>: the body of the command</li> </ul> <p>The <code>GeneratorCommand</code> base class provides some helper methods:</p> <ul> <li><code>getNameInput()</code>: returns the name passed from command line execution</li> <li><code>qualifyClass(string $name)</code>: returns the qualified class name for a given class name</li> <li><code>getPath(string $name)</code>: returns the file path for a given name</li> </ul> <p>Consider the following example for the <code>php artisan make:foo MyFoo</code> command:</p> <pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Console;\n\nuse Illuminate\\Console\\GeneratorCommand;\n\nclass MakeFooCommand extends GeneratorCommand\n{\n    protected $name = 'make:foo';\n\n    protected $description = 'Create a new foo class';\n\n    protected $type = 'Foo';\n\n    protected function getStub()\n    {\n        return __DIR__ . '/stubs/foo.php.stub';\n    }\n\n    protected function getDefaultNamespace($rootNamespace)\n    {\n        return $rootNamespace . '\\Foo';\n    }\n\n    public function handle()\n    {\n        parent::handle();\n\n        $this-&gt;doOtherOperations();\n    }\n\n    protected function doOtherOperations()\n    {\n        // Get the fully qualified class name (FQN)\n        $class = $this-&gt;qualifyClass($this-&gt;getNameInput());\n\n        // get the destination path, based on the default namespace\n        $path = $this-&gt;getPath($class);\n\n        $content = file_get_contents($path);\n\n        // Update the file content with additional data (regular expressions)\n\n        file_put_contents($path, $content);\n    }\n}\n</code></pre> <p>Note that the Generator Command will export the class to a directory based on the namespace specified in the <code>getDefaultNamespace()</code> method.</p> <p>As with the <code>InstallBlogPackage</code> command, we have to register this new command in the <code>BlogPackageServiceProvider</code>:</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nuse JohnDoe\\BlogPackage\\Console\\{InstallBlogPackage, MakeFooCommand};\n\npublic function boot()\n{\n  if ($this-&gt;app-&gt;runningInConsole()) {\n    // publish config file\n\n    $this-&gt;commands([\n        InstallBlogPackage::class,\n        MakeFooCommand::class, // registering the new command\n    ]);\n  }\n}\n</code></pre>","tags":["Artisan","Commands","Testing Commands","Test-Only Commands"]},{"location":"06-artisan-commands/#creating-a-stub","title":"Creating a stub","text":"<p>You are free to store stubs in a different directory, but we'll store the stubs in the <code>Console/stubs</code> directory in this example. For our <code>Foo</code> class generator, the stub could look as follows:</p> stubs/foo.php.stub<pre><code>&lt;?php\n\nnamespace DummyNamespace;\n\nuse JohnDoe\\BlogPackage\\Foo;\n\nclass DummyClass implements Foo\n{\n    public function myFoo()\n    {\n        // foo\n    }\n}\n</code></pre> <p>Note that <code>DummyNamespace</code> and <code>DummyClass</code> are placeholders, strictly defined in the <code>GeneratorCommand</code> base class. Laravel expects these specific names to replace them automatically with the correct values.</p>","tags":["Artisan","Commands","Testing Commands","Test-Only Commands"]},{"location":"06-artisan-commands/#testing-generator-commands","title":"Testing Generator Commands","text":"<p>We can add a feature test for this command in the <code>tests/Feature</code> directory, called <code>MakeFooCommandTest.php</code>, which verifies that a new file is created and contains the correct contents:</p> <pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests\\Feature;\n\nuse Illuminate\\Support\\Facades\\File;\nuse Illuminate\\Support\\Facades\\Artisan;\nuse JohnDoe\\BlogPackage\\Tests\\TestCase;\n\nclass MakeFooCommandTest extends TestCase\n{\n    /** @test */\n    function it_creates_a_new_foo_class()\n    {\n        // destination path of the Foo class\n        $fooClass = app_path('Foo/MyFooClass.php');\n\n        // make sure we're starting from a clean state\n        if (File::exists($fooClass)) {\n            unlink($fooClass);\n        }\n\n        $this-&gt;assertFalse(File::exists($fooClass));\n\n        // Run the make command\n        Artisan::call('make:foo MyFooClass');\n\n        // Assert a new file is created\n        $this-&gt;assertTrue(File::exists($fooClass));\n\n        // Assert the file contains the right contents\n        $expectedContents = &lt;&lt;&lt;CLASS\n&lt;?php\n\nnamespace App\\Foo;\n\nuse JohnDoe\\BlogPackage\\Foo;\n\nclass MyFooClass implements Foo\n{\n    public function myFoo()\n    {\n        // foo\n    }\n}\nCLASS;\n\n        $this-&gt;assertEquals($expectedContents, file_get_contents($fooClass));\n    }\n}\n</code></pre>","tags":["Artisan","Commands","Testing Commands","Test-Only Commands"]},{"location":"06-artisan-commands/#creating-a-test-only-command","title":"Creating a Test-Only Command","text":"<p>There are some situations where you would like to only use a particular command for testing and not in your application itself. For example, when your package provides a <code>Trait</code> that Command classes can use. To test the trait, you want to use an actual command.</p> <p>Using an actual command solely for test purposes doesn't add functionality to the package and should not be published. A viable solution is to register the Command only in the tests, by hooking into Laravel's <code>Application::starting()</code> method as proposed by Marcel Pociot:</p> <pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests\\Feature;\n\nuse JohnDoe\\BlogPackage\\Tests\\Commands\\TestCommand;\nuse Illuminate\\Console\\Application;\nuse Illuminate\\Support\\Facades\\Artisan;\nuse Orchestra\\Testbench\\TestCase;\n\nclass TestCommandTest extends TestCase\n{\n   /** @test **/\n   public function it_does_a_certain_thing()\n   {\n        Application::starting(function ($artisan) {\n            $artisan-&gt;add(app(TestCommand::class));\n        });\n\n        // Running the command\n        Artisan::call('test-command:run');\n\n       // Assertions...\n   }\n}\n</code></pre>","tags":["Artisan","Commands","Testing Commands","Test-Only Commands"]},{"location":"07-configuration-files/","title":"Configuration Files","text":"<p>It is quite likely that your package allows configuration by the end-user.</p> <p>If you want to offer custom configuration options, create a new <code>config</code> directory in the package's root and add a file called <code>config.php</code>, which returns an array of options.</p> config/config.php<pre><code>&lt;?php\n\nreturn [\n  'posts_table' =&gt; 'posts',\n  // other options...\n];\n</code></pre>","tags":["Configuration","Publishing Configuration"]},{"location":"07-configuration-files/#merging-into-the-existing-configuration","title":"Merging Into the Existing Configuration","text":"<p>After registering the config file in the <code>register()</code> method of our service provider under a specific \"key\" ('blogpackage' in our demo), we can access the config values from the config helper by prefixing our \"key\" as follows: <code>config('blogpackage.posts_table')</code>.</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\npublic function register()\n{\n  $this-&gt;mergeConfigFrom(__DIR__.'/../config/config.php', 'blogpackage');\n}\n</code></pre>","tags":["Configuration","Publishing Configuration"]},{"location":"07-configuration-files/#exporting","title":"Exporting","text":"<p>To allow users to modify the default config values, we need to provide them with the option to export the config file. We can register all \"publishables\" within the <code>boot()</code> method of the package's service provider. Since we only want to offer this functionality whenever the package is booted from the console, we'll first check if the current app runs in the console. We'll register the publishable config file under the 'config' tag (the second parameter of the <code>$this-&gt;publishes()</code> function call).</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\npublic function boot()\n{\n  if ($this-&gt;app-&gt;runningInConsole()) {\n\n    $this-&gt;publishes([\n      __DIR__.'/../config/config.php' =&gt; config_path('blogpackage.php'),\n    ], 'config');\n\n  }\n}\n</code></pre> <p>The config file can now be exported using the command listed below, creating a <code>blogpackage.php</code> file in the <code>/config</code> directory of the Laravel project using this package.</p> <pre><code>php artisan vendor:publish --provider=\"JohnDoe\\BlogPackage\\BlogPackageServiceProvider\" --tag=\"config\"\n</code></pre>","tags":["Configuration","Publishing Configuration"]},{"location":"08-models-and-migrations/","title":"Models &amp; Migrations","text":"<p>There are scenarios where you'll need to ship one or more Eloquent models with your package. For example, when you're developing a Blog related package that includes a <code>Post</code> model.</p> <p>This chapter will cover how to provide Eloquent models within your package, including migrations, tests, and how to possibly add a relationship to the <code>App\\User</code> model that ships with Laravel.</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#models","title":"Models","text":"<p>Models in our package do not differ from models we would use in a standard Laravel application. Since we required the Orchestra Testbench, we can create a model extending the Laravel Eloquent model and save it within the <code>src/Models</code> directory:</p> src/Models/Post.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Post extends Model\n{\n  use HasFactory;\n\n  // Disable Laravel's mass assignment protection\n  protected $guarded = [];\n}\n</code></pre> <p>There are multiple ways to generate models together with a migration automatically. The straightforward approach is to use a regular Laravel application and then copy over the artisan-generated files to your package and then update the namespaces.</p> <p>If you are looking for ways to automate the scaffolding within your package, you might install one of the following tools as a <code>dev</code> dependency within your package and use a CLI command to generate the scaffolds.</p> <ul> <li>Laravel Package Tools</li> <li>Laravel Packer</li> <li>Laravel Package Maker</li> </ul>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#migrations","title":"Migrations","text":"<p>Migrations live in the <code>database/migrations</code> folder in a Laravel application. In our package we mimic this file structure. Therefore, database migrations will not live in the <code>src/</code> directory but in their own <code>database/migrations</code> folder. Our package's root directory now contains at least two folders: <code>src/</code> and <code>database/</code>.</p> <p>After you\u2019ve generated a migration, copy it from your \u201cdummy\u201d Laravel application to the package\u2019s <code>database/migrations</code> folder.</p> database/migrations/2018_08_08_100000_create_posts_table.php<pre><code>&lt;?php\n\nuse Illuminate\\Database\\Migrations\\Migration;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Support\\Facades\\Schema;\n\nclass CreatePostsTable extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::create('posts', function (Blueprint $table) {\n            $table-&gt;id();\n            $table-&gt;timestamps();\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::dropIfExists('posts');\n    }\n}\n</code></pre> <p>From this point on, there are two possible approaches to present the end-user with our migration(s). We can either publish (specific) migrations (method 1) or load all migrations from our package automatically (method 2).</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#publishing-migrations-method-1","title":"Publishing Migrations (method 1)","text":"<p>In this approach, we register that our package \u201cpublishes\u201d its migrations. We can do that as follows in the <code>boot()</code> method of our package\u2019s service provider, employing the <code>publishes()</code> method, which takes two arguments:</p> <ol> <li> <p>an array of file paths (\"source path\" =&gt; \"destination path\")</p> </li> <li> <p>the name (\u201ctag\u201d) we assign to this group of related publishable assets.</p> </li> </ol> <p>In this approach, it is conventional to use a \"stubbed\" migration. This stub is exported to a real migration when the user of our package publishes the migrations. Therefore, rename any migrations to remove the timestamp and add a <code>.stub</code> extension. In our example migration, this would lead to: <code>create_posts_table.php.stub</code>.</p> <p>Next, we can implement exporting the migration(s) as follows:</p> <pre><code>&lt;?php\n\nclass BlogPackageServiceProvider extends ServiceProvider\n{\n  public function boot()\n  {\n    if ($this-&gt;app-&gt;runningInConsole()) {\n      // Export the migration\n      if (! class_exists('CreatePostsTable')) {\n        $this-&gt;publishes([\n          __DIR__ . '/../database/migrations/create_posts_table.php.stub' =&gt; database_path('migrations/' . date('Y_m_d_His', time()) . '_create_posts_table.php'),\n          // you can add any number of migrations here\n        ], 'migrations');\n      }\n    }\n  }\n}\n</code></pre> <p>In the code listed above, we first check if the application is running in the console. Next, we'll check if the user already published the migrations. If not, we will publish the <code>create_posts_table</code> migration in the migrations folder in the database path, prefixed with the current date and time.</p> <p>The migrations of this package are now publishable under the \u201cmigrations\u201d tag via:</p> <pre><code>php artisan vendor:publish --provider=\"JohnDoe\\BlogPackage\\BlogPackageServiceProvider\" --tag=\"migrations\"\n</code></pre>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#loading-migrations-automatically-method-2","title":"Loading Migrations Automatically (method 2)","text":"<p>While the method described above gives full control over which migrations are published, Laravel offers an alternative approach making use of the <code>loadMigrationsFrom</code> helper (see docs). By specifying a migrations directory in the package's service provider, all migrations will be executed when the end-user executes <code>php artisan migrate</code> from within their Laravel application.</p> <pre><code>&lt;?php\n\nclass BlogPackageServiceProvider extends ServiceProvider\n{\n  public function boot()\n  {\n    $this-&gt;loadMigrationsFrom(__DIR__ . '/../database/migrations');\n  }\n}\n</code></pre> <p>Make sure to include a proper timestamp to your migrations, otherwise, Laravel can't process them. For example: <code>2018_08_08_100000_example_migration.php</code>. You can not use a stub (like in method 1) when choosing this approach.</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#testing-models-and-migrations","title":"Testing Models and Migrations","text":"<p>As we create an example test, we will follow some of the basics of test-driven-development (TDD) here. Whether or not you practice TDD in your typical workflow, explaining the steps here helps expose possible problems you might encounter along the way, thus making troubleshooting simpler. Let's get started:</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#writing-a-unit-test","title":"Writing a Unit Test","text":"<p>Now that we\u2019ve set up PHPunit, let\u2019s create a unit test for our Post model in the <code>tests/Unit</code> directory called <code>PostTest.php</code>. Let's write a test that verifies a <code>Post</code> has a title:</p> tests/Unit/PostTest.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests\\Unit;\n\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse JohnDoe\\BlogPackage\\Tests\\TestCase;\nuse JohnDoe\\BlogPackage\\Models\\Post;\n\nclass PostTest extends TestCase\n{\n  use RefreshDatabase;\n\n  /** @test */\n  function a_post_has_a_title()\n  {\n    $post = Post::factory()-&gt;create(['title' =&gt; 'Fake Title']);\n    $this-&gt;assertEquals('Fake Title', $post-&gt;title);\n  }\n}\n</code></pre> <p>Note: we're using the <code>RefreshDatabase</code> trait to be sure that we start with a clean database state before every test.</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#running-the-tests","title":"Running the Tests","text":"<p>We can run our test suite by calling the PHPUnit binary in our vendor directory using <code>./vendor/bin/phpunit</code>. However, let\u2019s alias this to <code>test</code> in our <code>composer.json</code> file by adding a \u201cscript\u201d:</p> composer.json<pre><code>{\n  ...,\n\n  \"autoload-dev\": {},\n\n  \"scripts\": {\n    \"test\": \"vendor/bin/phpunit\",\n    \"test-f\": \"vendor/bin/phpunit --filter\"\n  }\n}\n</code></pre> <p>We can now run <code>composer test</code> to run all of our tests and <code>composer test-f</code> followed by a test method/class's name to run that test solely.</p> <p>When we run <code>composer test-f a_post_has_a_title</code>, it leads us to the following error:</p> <pre><code>Error: Class 'Database\\Factories\\JohnDoe\\BlogPackage\\Models\\PostFactory' not found\n</code></pre> <p>The abovementioned error tells us that we need to create a model factory for the <code>Post</code> model.</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#creating-a-model-factory","title":"Creating a Model Factory","text":"<p>Let\u2019s create a <code>PostFactory</code> in the <code>database/factories</code> folder:</p> database/factories/PostFactory.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Database\\Factories;\n\nuse JohnDoe\\BlogPackage\\Models\\Post;\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\n\nclass PostFactory extends Factory\n{\n    protected $model = Post::class;\n\n    public function definition()\n    {\n        return [\n            //\n        ];\n    }\n}\n</code></pre> <p>As with the <code>src</code> folder, for our package users to be able to use our model factories, we'll need to register the <code>database/factories</code> folder within a namespace in our <code>composer.json</code> file:</p> composer.json<pre><code>{\n  ...,\n  \"autoload\": {\n    \"psr-4\": {\n      \"JohnDoe\\\\BlogPackage\\\\\": \"src\",\n      \"JohnDoe\\\\BlogPackage\\\\Database\\\\Factories\\\\\": \"database/factories\"\n    }\n  },\n  ...\n}\n</code></pre> <p>After setting it up, don't forget to run <code>composer dump-autoload</code>.</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#configuring-our-model-factory","title":"Configuring our Model factory","text":"<p>Rerunning our tests lead to the following error:</p> <pre><code>Error: Class 'Database\\Factories\\JohnDoe\\BlogPackage\\Models\\PostFactory' not found\n</code></pre> <p>The above mentioned error is caused by Laravel, which tries to resolve the Model class for our <code>PostFactory</code> assuming the default namespaces of a usual project (as of version 8.x, <code>App</code> or <code>App\\Models</code>). To be able to instantiate the right Model from our package with the <code>Post::factory()</code> method, we need to add the following method to our <code>Post</code> Model:</p> src/Models/Post.php<pre><code>&lt;?php\n\nprotected static function newFactory()\n{\n    return \\JohnDoe\\BlogPackage\\Database\\Factories\\PostFactory::new();\n}\n</code></pre> <p>However, the tests will still fail since we haven\u2019t created the <code>posts</code> table in our in-memory SQLite database. We need to tell our tests to first perform all migrations before running the tests.</p> <p>Let\u2019s load the migrations in the <code>getEnvironmentSetUp()</code> method of our <code>TestCase</code>:</p> tests/TestCase.php<pre><code>&lt;?php\n\npublic function getEnvironmentSetUp($app)\n{\n  // import the CreatePostsTable class from the migration\n  include_once __DIR__ . '/../database/migrations/create_posts_table.php.stub';\n\n  // run the up() method of that migration class\n  (new \\CreatePostsTable)-&gt;up();\n}\n</code></pre> <p>Now, running the tests again will lead to the expected error of no \u2018title\u2019 column being present on the \u2018posts\u2019 table. Let\u2019s fix that in the <code>create_posts_table.php.stub</code> migration:</p> database/migrations/create_posts_table.php.stub<pre><code>&lt;?php\n\nSchema::create('posts', function (Blueprint $table) {\n    $table-&gt;id();\n    $table-&gt;string('title');\n    $table-&gt;timestamps();\n});\n</code></pre> <p>After running the test, you should see it passing.</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#adding-tests-for-other-columns","title":"Adding Tests for Other Columns","text":"<p>Let\u2019s add tests for the \u201cbody\u201d and \u201cauthor_id\u201d:</p> tests/Unit/PostTest.php<pre><code>&lt;?php\n\nclass PostTest extends TestCase\n{\n  use RefreshDatabase;\n\n  /** @test */\n  function a_post_has_a_title()\n  {\n    $post = Post::factory()-&gt;create(['title' =&gt; 'Fake Title']);\n    $this-&gt;assertEquals('Fake Title', $post-&gt;title);\n  }\n\n  /** @test */\n  function a_post_has_a_body()\n  {\n    $post = Post::factory()-&gt;create(['body' =&gt; 'Fake Body']);\n    $this-&gt;assertEquals('Fake Body', $post-&gt;body);\n  }\n\n  /** @test */\n  function a_post_has_an_author_id()\n  {\n    // Note that we are not assuming relations here, just that we have a column to store the 'id' of the author\n    $post = Post::factory()-&gt;create(['author_id' =&gt; 999]); // we choose an off-limits value for the author_id so it is unlikely to collide with another author_id in our tests\n    $this-&gt;assertEquals(999, $post-&gt;author_id);\n  }\n}\n</code></pre> <p>You can continue driving this out with TDD on your own, running the tests, exposing the next thing to implement, and testing again.</p> <p>Eventually you\u2019ll end up with a model factory and migration as follows:</p> database/factories/PostFactory.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Database\\Factories;\n\nuse JohnDoe\\BlogPackage\\Models\\Post;\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\n\nclass PostFactory extends Factory\n{\n    protected $model = Post::class;\n\n    public function definition()\n    {\n        return [\n            'title'     =&gt; $this-&gt;faker-&gt;words(3, true),\n            'body'      =&gt; $this-&gt;faker-&gt;paragraph,\n            'author_id' =&gt; 999,\n        ];\n    }\n}\n</code></pre> <p>For now, we hard-coded the \u2018author_id\u2019. In the next section, we'll see how we could whip up a relationship with a <code>User</code> model.</p> database/migrations/create_posts_table.php.stub<pre><code>&lt;?php\n\nSchema::create('posts', function (Blueprint $table) {\n    $table-&gt;id();\n    $table-&gt;string('title');\n    $table-&gt;text('body');\n    $table-&gt;unsignedBigInteger('author_id');\n    $table-&gt;timestamps();\n});\n</code></pre>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#models-related-to-appuser","title":"Models related to App\\User","text":"<p>Now that we have an \u201cauthor_id\u201d column on our <code>Post</code> model, let\u2019s create a relationship between a <code>Post</code> and a <code>User</code>. However, we have a problem since we need a <code>User</code> model, but this model also comes out-of-the-box with a fresh installation of the Laravel framework\u2026</p> <p>We can\u2019t just provide our own <code>User</code> model, since you likely want your end-user to be able to hook up the <code>User</code> model from their Laravel app.</p> <p>Below, there are two options to create a relation</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#approach-1-fetching-the-user-model-from-the-auth-configuration","title":"Approach 1: Fetching the User model from the Auth configuration","text":"<p>If you simply want to create a relationship between authenticated users and e.g. a <code>Post</code> model, the easiest option is to reference the Model that is used in the <code>config/auth.php</code> file. By default, this is the <code>App\\Models\\User</code> Eloquent model.</p> <p>If you just want to target the Eloquent model that is responsible for the authentication, create a <code>belongsToMany</code> relationship on the <code>Post</code> model as follows:</p> <pre><code>&lt;?php\n\n// Post model\nclass Post extends Model\n{\n  public function author()\n  {\n    return $this-&gt;belongsTo(config('auth.providers.users.model'));\n  }\n}\n</code></pre> <p>However, what if the user of our package has an <code>Admin</code> and a <code>User</code> model and the author of a <code>Post</code> can be an <code>Admin</code> model or a <code>User</code> model ? In such cases, you can opt for a polymorphic relationship.</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#approach-2-using-a-polymorphic-relationship","title":"Approach 2: Using a Polymorphic Relationship","text":"<p>Instead of opting for a conventional one-to-many relationship (a user can have many posts, and a post belongs to a user), we\u2019ll use a polymorphic one-to-many relationship where a <code>Post</code> morphs to a specific related model (not necessarily a <code>User</code> model).</p> <p>Let\u2019s compare the standard and polymorphic relationships.</p> <p>Definition of a standard one-to-many relationship:</p> <pre><code>&lt;?php\n\n// Post model\nclass Post extends Model\n{\n  public function author()\n  {\n    return $this-&gt;belongsTo(User::class);\n  }\n}\n\n// User model\nclass User extends Model\n{\n  public function posts()\n  {\n    return $this-&gt;hasMany(Post::class);\n  }\n}\n</code></pre> <p>Definition of a polymorphic one-to-many relationship:</p> <pre><code>&lt;?php\n\n// Post model\nclass Post extends Model\n{\n  public function author()\n  {\n    return $this-&gt;morphTo();\n  }\n}\n\n// User (or other) model\nuse JohnDoe\\BlogPackage\\Models\\Post;\n\nclass Admin extends Model\n{\n  public function posts()\n  {\n    return $this-&gt;morphMany(Post::class, 'author');\n  }\n}\n</code></pre> <p>After adding this <code>author()</code> method to our Post model, we need to update our <code>create_posts_table_migration.php.stub</code> file to reflect our polymorphic relationship. Since we named the method \u201cauthor\u201d, Laravel expects an \u201cauthor_id\u201d and an \u201cauthor_type\u201d field. The latter contains a string of the namespaced model we refer to (for example, \u201cApp\\User\u201d).</p> <pre><code>&lt;?php\n\nSchema::create('posts', function (Blueprint $table) {\n    $table-&gt;id();\n    $table-&gt;string('title');\n    $table-&gt;text('body');\n    $table-&gt;unsignedBigInteger('author_id');\n    $table-&gt;string('author_type');\n    $table-&gt;timestamps();\n});\n</code></pre> <p>Now, we need a way to provide our end-user with the option to allow specific models to have a relationship with our <code>Post</code> model. Traits offer an excellent solution for this exact purpose.</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#providing-a-trait","title":"Providing a Trait","text":"<p>Create a <code>Traits</code> folder in the <code>src/</code> directory and add the following <code>HasPosts</code> trait:</p> src/Traits/HasPosts.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Traits;\n\nuse JohnDoe\\BlogPackage\\Models\\Post;\n\ntrait HasPosts\n{\n  public function posts()\n  {\n    return $this-&gt;morphMany(Post::class, 'author');\n  }\n}\n</code></pre> <p>Now the end-user can add a <code>use HasPosts</code> statement to any of their models (likely the <code>User</code> model), which would automatically register the one-to-many relationship with our <code>Post</code> model. This allows creating new posts as follows:</p> <pre><code>&lt;?php\n\n// Given we have a User model, using the HasPosts trait\n$user = User::first();\n\n// We can create a new post from the relationship\n$user-&gt;posts()-&gt;create([\n  'title' =&gt; 'Some title',\n  'body' =&gt; 'Some body',\n]);\n</code></pre>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#testing-the-polymorphic-relationship","title":"Testing the Polymorphic Relationship","text":"<p>Of course, we want to prove that any model using our <code>HasPost</code> trait can create new posts and that those posts are stored correctly.</p> <p>Therefore, we\u2019ll create a new <code>User</code> model, not within the <code>src/Models/</code> directory, but rather in our <code>tests/</code> directory.</p> <p>To create users within our tests we'll need to overwrite the <code>UserFactory</code> provided by the Orchestra Testbench package, as shown below.</p> tests/UserFactory.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests;\n\nuse Orchestra\\Testbench\\Factories\\UserFactory as TestbenchUserFactory;\n\nclass UserFactory extends TestbenchUserFactory\n{\n  protected $model = User::class;\n\n    /**\n     * Define the model's default state.\n     *\n     * @return array\n     */\n    public function definition()\n    {\n        return [\n            'name' =&gt; $this-&gt;faker-&gt;name,\n            'email' =&gt; $this-&gt;faker-&gt;unique()-&gt;safeEmail,\n            'email_verified_at' =&gt; now(),\n            'password' =&gt; bcrypt('password'),\n            'remember_token' =&gt; \\Illuminate\\Support\\Str::random(10),\n        ];\n    }\n}\n</code></pre> <p>In the <code>User</code> model we\u2019ll use the same traits available on the <code>User</code> model that ships with a standard Laravel project to stay close to a real-world scenario. Also, we use our own <code>HasPosts</code> trait and <code>UserFactory</code>:</p> tests/User.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests;\n\nuse Illuminate\\Auth\\Authenticatable;\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Foundation\\Auth\\Access\\Authorizable;\nuse Illuminate\\Contracts\\Auth\\Authenticatable as AuthenticatableContract;\nuse Illuminate\\Contracts\\Auth\\Access\\Authorizable as AuthorizableContract;\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse JohnDoe\\BlogPackage\\Traits\\HasPosts;\n\nclass User extends Model implements AuthorizableContract, AuthenticatableContract\n{\n    use HasPosts, Authorizable, Authenticatable, HasFactory;\n\n    protected $guarded = [];\n\n    protected $table = 'users';\n\n    protected static function newFactory()\n    {\n        return UserFactory::new();\n    }\n}\n</code></pre> <p>Now that we have a <code>User</code> model, we also need to add a new migration (the standard users table migration that ships with Laravel) to our database<code>/migrations</code> as <code>create_users_table.php.stub</code>:</p> database/migrations/create_users_table.php.stub<pre><code>&lt;?php\n\nuse Illuminate\\Database\\Migrations\\Migration;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Support\\Facades\\Schema;\n\nclass CreateUsersTable extends Migration\n{\n    /**\n     * Run the migrations.\n     *\n     * @return void\n     */\n    public function up()\n    {\n        Schema::create('users', function (Blueprint $table) {\n            $table-&gt;id();\n            $table-&gt;string('name');\n            $table-&gt;string('email')-&gt;unique();\n            $table-&gt;timestamp('email_verified_at')-&gt;nullable();\n            $table-&gt;string('password');\n            $table-&gt;rememberToken();\n            $table-&gt;timestamps();\n        });\n    }\n\n    /**\n     * Reverse the migrations.\n     *\n     * @return void\n     */\n    public function down()\n    {\n        Schema::dropIfExists('users');\n    }\n}\n</code></pre> <p>Also load the migration at the beginning of our tests, by including the migration and performing its <code>up()</code> method in our <code>TestCase</code>:</p> tests/TestCase.php<pre><code>&lt;?php\n\npublic function getEnvironmentSetUp($app)\n{\n    include_once __DIR__ . '/../database/migrations/create_posts_table.php.stub';\n    include_once __DIR__ . '/../database/migrations/create_users_table.php.stub';\n\n    // run the up() method (perform the migration)\n    (new \\CreatePostsTable)-&gt;up();\n    (new \\CreateUsersTable)-&gt;up();\n}\n</code></pre>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"08-models-and-migrations/#updating-our-post-model-factory","title":"Updating Our Post Model Factory","text":"<p>Now that we can whip up <code>User</code> models with our new factory, let\u2019s create a new <code>User</code> in our <code>PostFactory</code> and then assign it to \u201cauthor_id\u201d and \u201cauthor_type\u201d:</p> database/factories/PostFactory.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Database\\Factories;\n\nuse JohnDoe\\BlogPackage\\Models\\Post;\nuse Illuminate\\Database\\Eloquent\\Factories\\Factory;\nuse JohnDoe\\BlogPackage\\Tests\\User;\n\nclass PostFactory extends Factory\n{\n    /**\n     * The name of the factory's corresponding model.\n     *\n     * @var string\n     */\n    protected $model = Post::class;\n\n    /**\n     * Define the model's default state.\n     *\n     * @return array\n     */\n    public function definition()\n    {\n        $author = User::factory()-&gt;create();\n\n        return [\n            'title'     =&gt; $this-&gt;faker-&gt;words(3, true),\n            'body'      =&gt; $this-&gt;faker-&gt;paragraph,\n            'author_id' =&gt; $author-&gt;id,\n            'author_type' =&gt; get_class($author)\n        ];\n    }\n}\n</code></pre> <p>Next, we update the <code>Post</code> unit test to verify an \u2018author_type\u2019 can be specified.</p> tests/Unit/PostTest.php<pre><code>&lt;?php\n\nclass PostTest extends TestCase\n{\n  // other tests...\n\n  /** @test */\n  function a_post_has_an_author_type()\n  {\n    $post = Post::factory()-&gt;create(['author_type' =&gt; 'Fake\\User']);\n    $this-&gt;assertEquals('Fake\\User', $post-&gt;author_type);\n  }\n}\n</code></pre> <p>Finally, we need to verify that our test <code>User</code> can create a <code>Post</code> and it is stored correctly.</p> <p>Since we are not creating a new post using a call to a specific route in the application, let's store this test in the <code>Post</code> unit test. In the next section on \u201cRoutes &amp; Controllers\u201d, we\u2019ll make a POST request to an endpoint to create a new <code>Post</code> model and therefore divert to a Feature test.</p> <p>A Unit test that verifies the desired behavior between a <code>User</code> and a <code>Post</code> could look as follows:</p> tests/Unit/PostTest.php<pre><code>&lt;?php\n\nclass PostTest extends TestCase\n{\n  // other tests...\n\n  /** @test */\n  function a_post_belongs_to_an_author()\n  {\n    // Given we have an author\n    $author = User::factory()-&gt;create();\n    // And this author has a Post\n    $author-&gt;posts()-&gt;create([\n        'title' =&gt; 'My first fake post',\n        'body'  =&gt; 'The body of this fake post',\n    ]);\n\n    $this-&gt;assertCount(1, Post::all());\n    $this-&gt;assertCount(1, $author-&gt;posts);\n\n    // Using tap() to alias $author-&gt;posts()-&gt;first() to $post\n    // To provide cleaner and grouped assertions\n    tap($author-&gt;posts()-&gt;first(), function ($post) use ($author) {\n        $this-&gt;assertEquals('My first fake post', $post-&gt;title);\n        $this-&gt;assertEquals('The body of this fake post', $post-&gt;body);\n        $this-&gt;assertTrue($post-&gt;author-&gt;is($author));\n    });\n  }\n}\n</code></pre> <p>At this stage, all of the tests should be passing.</p>","tags":["Models","Migrations","Testing Models","Unit Test"]},{"location":"09-routing/","title":"Routing","text":"<p>Sometimes you want to expose additional routes to the end-user of your package.</p> <p>Since we're offering a <code>Post</code> model, let's add some RESTful routes. To keep things simple, we're just going to implement 3 of the RESTful routes:</p> <ul> <li>show all posts ('index')</li> <li>show a single post ('show')</li> <li>store a new post ('store')</li> </ul>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#controllers","title":"Controllers","text":"","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#creating-a-base-controller","title":"Creating a Base Controller","text":"<p>We want to create a <code>PostController</code>.</p> <p>To make use of some traits the Laravel controllers offer, we'll first create our own base controller containing these traits in a <code>src/Http/Controllers</code> directory (resembling Laravel's folder structure) named <code>Controller.php</code>:</p> src/Http/Controllers/Controller.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Http\\Controllers;\n\nuse Illuminate\\Foundation\\Bus\\DispatchesJobs;\nuse Illuminate\\Routing\\Controller as BaseController;\nuse Illuminate\\Foundation\\Validation\\ValidatesRequests;\nuse Illuminate\\Foundation\\Auth\\Access\\AuthorizesRequests;\n\nclass Controller extends BaseController\n{\n    use AuthorizesRequests, DispatchesJobs, ValidatesRequests;\n}\n</code></pre>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#creating-a-controller-that-extends-base-controller","title":"Creating a Controller That Extends Base Controller","text":"<p>Now, let's create a PostController in the <code>src/Http/Controllers</code> directory, starting first with the 'store' method:</p> src/Http/Controllers/PostController<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Http\\Controllers;\n\nclass PostController extends Controller\n{\n    public function index()\n    {\n        //\n    }\n\n    public function show()\n    {\n        //\n    }\n\n    public function store()\n    {\n        // Let's assume we need to be authenticated\n        // to create a new post\n        if (! auth()-&gt;check()) {\n            abort (403, 'Only authenticated users can create new posts.');\n        }\n\n        request()-&gt;validate([\n            'title' =&gt; 'required',\n            'body'  =&gt; 'required',\n        ]);\n\n        // Assume the authenticated user is the post's author\n        $author = auth()-&gt;user();\n\n        $post = $author-&gt;posts()-&gt;create([\n            'title'     =&gt; request('title'),\n            'body'      =&gt; request('body'),\n        ]);\n\n        return redirect(route('posts.show', $post));\n    }\n}\n</code></pre>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#routes","title":"Routes","text":"","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#defining-routes","title":"Defining Routes","text":"<p>Now that we have a controller, create a new <code>routes/</code> directory in our package's root and add a <code>web.php</code> file containing the three RESTful routes we've mentioned above.</p> routes/web.php<pre><code>&lt;?php\n\nuse Illuminate\\Support\\Facades\\Route;\nuse JohnDoe\\BlogPackage\\Http\\Controllers\\PostController;\n\nRoute::get('/posts', [PostController::class, 'index'])-&gt;name('posts.index');\nRoute::get('/posts/{post}', [PostController::class, 'show'])-&gt;name('posts.show');\nRoute::post('/posts', [PostController::class, 'store'])-&gt;name('posts.store');\n</code></pre>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#registering-routes-in-the-service-provider","title":"Registering Routes in the Service Provider","text":"<p>Before we can use these routes, we need to register them in the <code>boot()</code> method of our Service Provider:</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\npublic function boot()\n{\n  // ... other things\n  $this-&gt;loadRoutesFrom(__DIR__.'/../routes/web.php');\n}\n</code></pre>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#configurable-route-prefix-and-middleware","title":"Configurable Route Prefix and Middleware","text":"<p>You may want to allow users to define a route prefix and middleware for the routes exposed by your package. Instead of registering the routes directly in the <code>boot()</code> method we'll register the routes using <code>Route::group</code>, passing in the dynamic configuration (prefix and middleware). Don't forget to import the corresponding <code>Route</code> facade.</p> <p>The following examples use a namespace of <code>blogpackage</code>. Don't forget to replace this with your package's namespace.</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nuse Illuminate\\Support\\Facades\\Route;\n\npublic function boot()\n{\n  // ... other things\n  $this-&gt;registerRoutes();\n}\n\nprotected function registerRoutes()\n{\n    Route::group($this-&gt;routeConfiguration(), function () {\n        $this-&gt;loadRoutesFrom(__DIR__.'/../routes/web.php');\n    });\n}\n\nprotected function routeConfiguration()\n{\n    return [\n        'prefix' =&gt; config('blogpackage.prefix'),\n        'middleware' =&gt; config('blogpackage.middleware'),\n    ];\n}\n</code></pre> <p>Specify a default route prefix and middleware in the package's <code>config.php</code> file:</p> <pre><code>&lt;?php\n[\n  'prefix' =&gt; 'blogger',\n  'middleware' =&gt; ['web'], // you probably want to include 'web' here\n]\n</code></pre> <p>In the above default configuration, all routes defined in <code>routes.web</code> need to be prefixed with <code>/blogger</code>. In this way, collision with potentially existing routes is avoided.</p>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#views","title":"Views","text":"<p>The 'index' and 'show' methods on the <code>PostController</code> need to render a view.</p>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#creating-the-blade-view-files","title":"Creating the Blade View Files","text":"<p>Create a new <code>resources/</code> folder at the root of our package. In that folder, create a subfolder named <code>views</code>. In the views folder, we'll create a <code>posts</code> subfolder in which we'll create two (extremely) simple templates.</p> <ol> <li><code>resources/views/posts/index.blade.php</code>:</li> </ol> <pre><code>&lt;h1&gt;Showing all Posts&lt;/h1&gt;\n\n@forelse ($posts as $post)\n    &lt;li&gt;{{ $post-&gt;title }}&lt;/li&gt;\n@empty\n    &lt;p&gt; 'No posts yet' &lt;/p&gt;\n@endforelse\n</code></pre> <ol> <li><code>resources/views/posts/show.blade.php</code>:</li> </ol> <pre><code>&lt;h1&gt;{{ $post-&gt;title }}&lt;/h1&gt;\n\n&lt;p&gt; {{ $post-&gt;body }}&lt;/p&gt;\n</code></pre> <p>Note: these templates would extend a base/master layout file in a real-world scenario.</p>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#registering-views-in-the-service-provider","title":"Registering Views in the Service Provider","text":"<p>Now that we have some views, we need to register that we want to load any views from our <code>resources/views</code> directory in the <code>boot()</code> method of our Service Provider. Important: provide a \"key\" as the second argument to <code>loadViewsFrom()</code> as you'll need to specify this key when returning a view from a controller (see next section).</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\npublic function boot()\n{\n  // ... other things\n  $this-&gt;loadViewsFrom(__DIR__.'/../resources/views', 'blogpackage');\n}\n</code></pre>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#returning-a-view-from-the-controller","title":"Returning a View from the Controller","text":"<p>We can now return the views we've created from the <code>PostController</code> (don't forget to import our <code>Post</code> model).</p> <p>Note the <code>blogpackage::</code> prefix, which matches the prefix we registered in our Service Provider.</p> src/Http/Controllers/PostController.php<pre><code>&lt;?php\n\nuse JohnDoe\\BlogPackage\\Models\\Post;\n\npublic function index()\n{\n    $posts = Post::all();\n\n    return view('blogpackage::posts.index', compact('posts'));\n}\n\npublic function show()\n{\n    $post = Post::findOrFail(request('post'));\n\n    return view('blogpackage::posts.show', compact('post'));\n}\n</code></pre>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#customizable-views","title":"Customizable Views","text":"<p>Chances are that you want to be able to let the users of your package customize the views. Similar to the database migrations, the views can be published if we register them to be exported in the <code>boot()</code> method of our service provider using the 'views' key of the publishes() method:</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nif ($this-&gt;app-&gt;runningInConsole()) {\n  // Publish views\n  $this-&gt;publishes([\n    __DIR__.'/../resources/views' =&gt; resource_path('views/vendor/blogpackage'),\n  ], 'views');\n\n}\n</code></pre> <p>The views can then be exported by users of our package using:</p> <pre><code>php artisan vendor:publish --provider=\"JohnDoe\\BlogPackage\\BlogPackageServiceProvider\" --tag=\"views\"\n</code></pre>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#view-components","title":"View Components","text":"<p>Since Laravel 8, it is possible to generate Blade components using <code>php artisan make:component MyComponent</code> which generates a base <code>MyComponent</code> class and a Blade <code>my-component.blade.php</code> file, which receives all public properties as defined in the <code>MyComponent</code> class. These components can then be reused and included in any view using the component syntax: <code>&lt;x-my-component&gt;</code> and closing <code>&lt;/x-my-component&gt;</code> (or the self-closing form). To learn more about Blade components, make sure to check out the Laravel documentation.</p> <p>In addition to generating Blade components using the artisan command, it is also possible to create a <code>my-component.blade.php</code> component without class. These are called anonymous components and are placed in the <code>views/components</code> directory by convention.</p> <p>This section will cover how to provide these type of Blade components in your package.</p>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#class-based-components","title":"Class Based Components","text":"<p>If you want to offer class based View Components in your package, first create a new <code>View/Components</code> directory in the <code>src</code> folder. Add a new class, for example <code>Alert.php</code>.</p> src/View/Components/Alert.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\View\\Components;\n\nuse Illuminate\\View\\Component;\n\nclass Alert extends Component\n{\n    public $message;\n\n    public function __construct($message)\n    {\n        $this-&gt;message = $message;\n    }\n\n    public function render()\n    {\n        return view('blogpackage::components.alert');\n    }\n}\n</code></pre> <p>Next, create a new <code>views/components</code> directory in the <code>resources</code> folder. Add a new Blade component <code>alert.blade.php</code>:</p> <pre><code>&lt;div&gt;\n  &lt;p&gt;This is an Alert&lt;/p&gt;\n\n  &lt;p&gt;{{ $message }}&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>Next, register the component in the Service Provider by the class and provide a prefix for the components. In our example, using 'blogpackage', the alert component will become available as <code>&lt;x-blogpackage-alert /&gt;</code>.</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nuse JohnDoe\\BlogPackage\\View\\Components\\Alert;\n\npublic function boot()\n{\n  // ... other things\n  $this-&gt;loadViewComponentsAs('blogpackage', [\n    Alert::class,\n  ]);\n}\n</code></pre>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#anonymous-view-components","title":"Anonymous View Components","text":"<p>If your package provides anonymous components, it suffices to add the <code>my-component.blade.php</code> Blade component to <code>resources/views/components</code> directory, given that you have specified the <code>loadViewsFrom</code> directory in your Service Provider as \"resources/views\". If you don't already, add the <code>loadViewsFrom</code> method to your Service Provider:</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\npublic function boot()\n{\n  // ... other things\n  $this-&gt;loadViewsFrom(__DIR__.'/../resources/views', 'blogpackage');\n}\n</code></pre> <p>Components (in the <code>resources/views/components</code> folder) can now be referenced prefixed by the defined namespace above (\"blogpackage\"):</p> <pre><code>  &lt;x-blogpackage::alert /&gt;\n</code></pre>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#customizable-view-components","title":"Customizable View Components","text":"<p>In order to let the end user of our package modify the provided Blade component(s), we first need to register the publishables into our Service Provider:</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nif ($this-&gt;app-&gt;runningInConsole()) {\n  // Publish view components\n  $this-&gt;publishes([\n      __DIR__.'/../src/View/Components/' =&gt; app_path('View/Components'),\n      __DIR__.'/../resources/views/components/' =&gt; resource_path('views/components'),\n  ], 'view-components');\n}\n</code></pre> <p>Now, it is possible to publish both files (class and Blade component) using:</p> <pre><code>php artisan vendor:publish --provider=\"JohnDoe\\BlogPackage\\BlogPackageServiceProvider\" --tag=\"view-components\"\n</code></pre> <p>Be aware that the end user needs to update the namespaces of the published component class and update the <code>render()</code> method to reference the Blade components of the Laravel application directly, instead of referencing the package namespace. Additionally, the Blade component no longer has to be namespaced since it was published to the Laravel application itself.</p>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#testing-routes","title":"Testing Routes","text":"<p>Let\u2019s verify that we can indeed create a post, show a post and show all posts with our provided routes, views, and controllers.</p>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"09-routing/#feature-test","title":"Feature Test","text":"<p>Create a new Feature test called <code>CreatePostTest.php</code> in the <code>tests/Feature</code> directory and add the following assertions to verify that authenticated users can indeed create new posts:</p> tests/Feature/CreatePostTest.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests\\Feature;\n\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse JohnDoe\\BlogPackage\\Models\\Post;\nuse JohnDoe\\BlogPackage\\Tests\\TestCase;\nuse JohnDoe\\BlogPackage\\Tests\\User;\n\nclass CreatePostTest extends TestCase\n{\n    use RefreshDatabase;\n\n    /** @test */\n    function authenticated_users_can_create_a_post()\n    {\n        // To make sure we don't start with a Post\n        $this-&gt;assertCount(0, Post::all());\n\n        $author = User::factory()-&gt;create();\n\n        $response = $this-&gt;actingAs($author)-&gt;post(route('posts.store'), [\n            'title' =&gt; 'My first fake title',\n            'body'  =&gt; 'My first fake body',\n        ]);\n\n        $this-&gt;assertCount(1, Post::all());\n\n        tap(Post::first(), function ($post) use ($response, $author) {\n            $this-&gt;assertEquals('My first fake title', $post-&gt;title);\n            $this-&gt;assertEquals('My first fake body', $post-&gt;body);\n            $this-&gt;assertTrue($post-&gt;author-&gt;is($author));\n            $response-&gt;assertRedirect(route('posts.show', $post));\n        });\n    }\n}\n</code></pre> <p>Additionally, we could verify that we require both a \"title\" and a \"body\" attribute when creating a new post:</p> tests/Feature/CreatePostTest.php<pre><code>&lt;?php\n\n/** @test */\nfunction a_post_requires_a_title_and_a_body()\n{\n    $author = User::factory()-&gt;create();\n\n    $this-&gt;actingAs($author)-&gt;post(route('posts.store'), [\n        'title' =&gt; '',\n        'body'  =&gt; 'Some valid body',\n    ])-&gt;assertSessionHasErrors('title');\n\n    $this-&gt;actingAs($author)-&gt;post(route('posts.store'), [\n        'title' =&gt; 'Some valid title',\n        'body'  =&gt; '',\n    ])-&gt;assertSessionHasErrors('body');\n}\n</code></pre> <p>Next, let's verify that unauthenticated users (or \"guests\") can not create new posts:</p> tests/Feature/CreatePostTest.php<pre><code>&lt;?php\n\n/** @test */\nfunction guests_can_not_create_posts()\n{\n    // We're starting from an unauthenticated state\n    $this-&gt;assertFalse(auth()-&gt;check());\n\n    $this-&gt;post(route('posts.store'), [\n       'title' =&gt; 'A valid title',\n       'body'  =&gt; 'A valid body',\n    ])-&gt;assertForbidden();\n}\n</code></pre> <p>Finally, let's verify the index route shows all posts, and the show route shows a specific post:</p> tests/Feature/CreatePostTest.php<pre><code>&lt;?php\n\n/** @test */\nfunction all_posts_are_shown_via_the_index_route()\n{\n    // Given we have a couple of Posts\n    Post::factory()-&gt;create([\n        'title' =&gt; 'Post number 1'\n    ]);\n    Post::factory()-&gt;create([\n        'title' =&gt; 'Post number 2'\n    ]);\n    Post::factory()-&gt;create([\n        'title' =&gt; 'Post number 3'\n    ]);\n\n    // We expect them to all show up\n    // with their title on the index route\n    $this-&gt;get(route('posts.index'))\n        -&gt;assertSee('Post number 1')\n        -&gt;assertSee('Post number 2')\n        -&gt;assertSee('Post number 3')\n        -&gt;assertDontSee('Post number 4');\n}\n\n/** @test */\nfunction a_single_post_is_shown_via_the_show_route()\n{\n    $post = Post::factory()-&gt;create([\n        'title' =&gt; 'The single post title',\n        'body'  =&gt; 'The single post body',\n    ]);\n\n    $this-&gt;get(route('posts.show', $post))\n        -&gt;assertSee('The single post title')\n        -&gt;assertSee('The single post body');\n}\n</code></pre> <p>Tip: whenever you are getting cryptic error messages from your tests, it might be helpful to disable graceful exception handling to get more insight into the error's origin. You can do so by declaring <code>$this-&gt;withoutExceptionHandling();</code> at the start of your test.</p>","tags":["Routing","Controllers","Views","RESTful","Testing Routing","Testing Controllers","Testing Views"]},{"location":"10-events-and-listeners/","title":"Events &amp; Listeners","text":"<p>Your package may want to offer support for hooking into Laravel's Events and Listeners.</p> <p>Laravel's events provide a way to hook into a particular activity that took place in your application. They can be emitted/dispatched using the <code>event()</code> helper, which accepts an <code>Event</code> class as a parameter. After an event is dispatched, the <code>handle()</code> method of all registered Listeners will be triggered. The listeners for a certain event are defined in the application's event service provider. An event-driven approach might help to keep the code loosely coupled.</p> <p>It is not uncommon that packages emit events upon performing a particular task. The end-user may or may not register their own listeners for an event you submit within a package. However, sometimes you might also want to listen within your package to your own events. For this, we'll need our package-specific event service provider and that's what we're looking at in this section.</p>","tags":["Events","Listeners","Testing Events","Testing Listeners"]},{"location":"10-events-and-listeners/#creating-a-new-event","title":"Creating a New Event","text":"<p>First, let's emit an event whenever a new <code>Post</code> is created via the route we set up earlier.</p> <p>In a new <code>Events</code> folder in the <code>src/</code> directory, create a new <code>PostWasCreated.php</code> file. In the <code>PostWasCreated</code> event class, we'll accept the created <code>Post</code> in the constructor and save it to a public instance variable <code>$post</code>.</p> src/Events/PostWasCreated.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Events;\n\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Foundation\\Events\\Dispatchable;\nuse JohnDoe\\BlogPackage\\Models\\Post;\n\nclass PostWasCreated\n{\n    use Dispatchable, SerializesModels;\n\n    public $post;\n\n    public function __construct(Post $post)\n    {\n        $this-&gt;post = $post;\n    }\n}\n</code></pre> <p>When creating a new <code>Post</code> in the <code>PostController</code>, we can now emit this event (don't forget to import it):</p> src/Http/Controllers/PostController.php<pre><code>&lt;?php\n\nuse JohnDoe\\BlogPackage\\Events\\PostWasCreated;\n\nclass PostController extends Controller\n{\n  public function store()\n  {\n    // authentication and validation checks...\n\n    $post = $author-&gt;posts()-&gt;create([...]);\n\n    event(new PostWasCreated($post));\n\n    return redirect(...);\n  }\n}\n</code></pre>","tags":["Events","Listeners","Testing Events","Testing Listeners"]},{"location":"10-events-and-listeners/#testing-the-event-was-emitted","title":"Testing the Event was Emitted","text":"<p>To be sure this event is successfully fired, add a test to our <code>CreatePostTest</code> feature test. We can easily fake Laravel's <code>Event</code> facade and make assertions (see Laravel documentation on Fakes) that the event was emitted and about the passed <code>Post</code> model.</p> tests/Feature/CreatePostTest.php<pre><code>&lt;?php\n\nuse Illuminate\\Support\\Facades\\Event;\nuse JohnDoe\\BlogPackage\\Events\\PostWasCreated;\nuse JohnDoe\\BlogPackage\\Models\\Post;\n\nclass CreatePostTest extends TestCase\n{\n  use RefreshDatabase;\n\n  // other tests\n\n  /** @test */\n  function an_event_is_emitted_when_a_new_post_is_created()\n  {\n      Event::fake();\n\n      $author = User::factory()-&gt;create();\n\n      $this-&gt;actingAs($author)-&gt;post(route('posts.store'), [\n        'title' =&gt; 'A valid title',\n        'body' =&gt; 'A valid body',\n      ]);\n\n      $post = Post::first();\n\n      Event::assertDispatched(PostWasCreated::class, function ($event) use ($post) {\n          return $event-&gt;post-&gt;id === $post-&gt;id;\n      });\n  }\n}\n</code></pre> <p>Now that we know that our event is fired correctly let's hook up our listener.</p>","tags":["Events","Listeners","Testing Events","Testing Listeners"]},{"location":"10-events-and-listeners/#creating-a-new-listener","title":"Creating a New Listener","text":"<p>After a <code>PostWasCreated</code> event was fired, let's modify our post's title for demonstrative purposes. In the <code>src/</code> directory, create a new folder <code>Listeners</code>. In this folder, create a new file that describes our action: <code>UpdatePostTitle.php</code>:</p> src/Listeners/UpdatePostTitle.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Listeners;\n\nuse JohnDoe\\BlogPackage\\Events\\PostWasCreated;\n\nclass UpdatePostTitle\n{\n    public function handle(PostWasCreated $event)\n    {\n        $event-&gt;post-&gt;update([\n            'title' =&gt; 'New: ' . $event-&gt;post-&gt;title\n        ]);\n    }\n}\n</code></pre>","tags":["Events","Listeners","Testing Events","Testing Listeners"]},{"location":"10-events-and-listeners/#testing-the-listener","title":"Testing the Listener","text":"<p>Although we've tested correct behavior when the <code>Event</code> is emitted, it is still worthwhile to have a separate test for the event's listener. If something breaks in the future, this test will lead you directly to the root of the problem: the listener.</p> <p>In this test, we'll assert that the listener's <code>handle()</code> method indeed changes the title of a blog post (in our silly example) by instantiating the <code>UpdatePostTitle</code> listener and passing a <code>PostWasCreated</code> event to its <code>handle()</code> method:</p> tests/Feature/CreatePostTest.php<pre><code>&lt;?php\n\n/** @test */\nfunction a_newly_created_posts_title_will_be_changed()\n{\n    $post = Post::factory()-&gt;create([\n        'title' =&gt; 'Initial title',\n    ]);\n\n    $this-&gt;assertEquals('Initial title', $post-&gt;title);\n\n    (new UpdatePostTitle())-&gt;handle(\n        new PostWasCreated($post)\n    );\n\n    $this-&gt;assertEquals('New: ' . 'Initial title', $post-&gt;fresh()-&gt;title);\n}\n</code></pre> <p>Now that we have a passing test for emitting the event, and we know that our listener shows the right behavior handling the event, let's couple the two together and create a custom Event Service Provider.</p>","tags":["Events","Listeners","Testing Events","Testing Listeners"]},{"location":"10-events-and-listeners/#creating-an-event-service-provider","title":"Creating an Event Service Provider","text":"<p>Like in Laravel, our package can have multiple service providers as long as we load them in our application service provider (in the next section).</p> <p>First, create a new folder <code>Providers</code> in the <code>src/</code> directory. Add a file called <code>EventServiceProvider.php</code> and register our Event and Listener:</p> src/Providers/EventServiceProvider.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Providers;\n\nuse Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\nuse JohnDoe\\BlogPackage\\Events\\PostWasCreated;\nuse JohnDoe\\BlogPackage\\Listeners\\UpdatePostTitle;\n\nclass EventServiceProvider extends ServiceProvider\n{\n    protected $listen = [\n        PostWasCreated::class =&gt; [\n            UpdatePostTitle::class,\n        ]\n    ];\n\n    /**\n     * Register any events for your application.\n     *\n     * @return void\n     */\n    public function boot()\n    {\n        parent::boot();\n    }\n}\n</code></pre>","tags":["Events","Listeners","Testing Events","Testing Listeners"]},{"location":"10-events-and-listeners/#registering-the-event-service-provider","title":"Registering the Event Service Provider","text":"<p>In our main <code>BlogPackageServiceProvider</code> we need to register our Event Service Provider in the <code>register()</code> method, as follows (don't forget to import it):</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nuse JohnDoe\\BlogPackage\\Providers\\EventServiceProvider;\n\npublic function register()\n{\n  $this-&gt;app-&gt;register(EventServiceProvider::class);\n}\n</code></pre>","tags":["Events","Listeners","Testing Events","Testing Listeners"]},{"location":"10-events-and-listeners/#testing-the-eventlistener-cascade","title":"Testing the Event/Listener Cascade","text":"<p>Earlier, we faked the <code>Event</code> facade. But in this test, we would like to confirm that an event was fired that led to a handle method on a listener and that eventually changed the title of our <code>Post</code>, exactly like we'd expect. The test assertion is easy: assume that the title was changed after creating a new post. We'll add this method to the <code>CreatePostTest</code> feature test:</p> tests/Feature/CreatePostTest.php<pre><code>&lt;?php\n\n/** @test */\nfunction the_title_of_a_post_is_updated_whenever_a_post_is_created()\n{\n    $author = factory(User::class)-&gt;create();\n\n    $this-&gt;actingAs($author)-&gt;post(route('posts.store'), [\n        'title' =&gt; 'A valid title',\n        'body' =&gt; 'A valid body',\n    ]);\n\n    $post = Post::first();\n\n    $this-&gt;assertEquals('New: ' . 'A valid title', $post-&gt;title);\n}\n</code></pre> <p>This test is green, but what if we run the full suite?</p>","tags":["Events","Listeners","Testing Events","Testing Listeners"]},{"location":"10-events-and-listeners/#fixing-the-failing-test","title":"Fixing the Failing Test","text":"<p>If we run the full suite with <code>composer test</code>, we see we have one failing test:</p> <pre><code>There was 1 failure:\n\n1) JohnDoe\\BlogPackage\\Tests\\Feature\\CreatePostTest::authenticated_users_can_create_a_post\nFailed asserting that two strings are equal.\n--- Expected\n+++ Actual\n@@ @@\n-'My first fake title'\n+'New: My first fake title'\n</code></pre> <p>The failing test is a regression from the Event we've introduced. There are two ways to fix this error:</p> <ol> <li>change the expected title in the authenticated_users_can_create_a_post test</li> <li>by faking any events before the test runs, which inhibits the actual handlers to be called</li> </ol> <p>It is very situational what happens to be the best option but let's go with option 2 for now.</p> tests/Feature/CreatePostTest.php<pre><code>&lt;?php\n\n/** @test */\nfunction authenticated_users_can_create_a_post()\n{\n    Event::fake();\n\n    $this-&gt;assertCount(0, Post::all());\n    // the rest of the test...\n</code></pre> <p>All tests are green, so let's move on to the next topic.</p>","tags":["Events","Listeners","Testing Events","Testing Listeners"]},{"location":"11-middleware/","title":"Middleware","text":"<p>If we look at an incoming HTTP request, this request is processed by Laravel's <code>index.php</code> file and sent through a series of pipelines. These include a series of ('before') middleware, where each will act on the incoming request before it eventually reaches the core of the application. A response is prepared from the application core, which is post-modified by all registered 'after' middleware before returning the response.</p> <p>That's why middleware is excellent for authentication, verifying tokens, or applying any other check. Laravel also uses middleware to strip out empty characters from strings and encrypt cookies.</p>","tags":["Middleware","Before Middlware","After Middleware","Route Middleware","Middleware Groups","Global Middleware","Testing Middleware"]},{"location":"11-middleware/#creating-middleware","title":"Creating Middleware","text":"<p>There are two types of middleware: 1) acting on the request before a response is returned (\"Before Middleware\"); or 2) acting on the response before returning (\"After Middleware\").</p> <p>Before discussing the two types of middleware, first create a new <code>Middleware</code> folder in the package's <code>src/Http</code> directory.</p>","tags":["Middleware","Before Middlware","After Middleware","Route Middleware","Middleware Groups","Global Middleware","Testing Middleware"]},{"location":"11-middleware/#before-middleware","title":"Before Middleware","text":"<p>A before middleware performs an action on the request and then calls the next middleware in line. Generally, a Before Middleware takes the following shape:</p> <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\n\nclass BeforeMiddleware\n{\n    public function handle($request, Closure $next)\n    {\n        // Perform action\n\n        return $next($request);\n    }\n}\n</code></pre> <p>As an illustration of a before middleware, let's add a middleware that capitalizes a 'title' parameter whenever present in the request (which would be silly in a real-world application).</p> <p>Add a file called <code>CapitalizeTitle.php</code> which provides a <code>handle()</code> method accepting both the current request and a <code>$next</code> action:</p> src/Http/Middleware/CapitalizeTitle.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Http\\Middleware;\n\nuse Closure;\n\nclass CapitalizeTitle\n{\n    public function handle($request, Closure $next)\n    {\n        if ($request-&gt;has('title')) {\n            $request-&gt;merge([\n                'title' =&gt; ucfirst($request-&gt;title)\n            ]);\n        }\n\n        return $next($request);\n    }\n}\n</code></pre>","tags":["Middleware","Before Middlware","After Middleware","Route Middleware","Middleware Groups","Global Middleware","Testing Middleware"]},{"location":"11-middleware/#testing-before-middleware","title":"Testing Before Middleware","text":"<p>Although we haven't registered the middleware yet, and it will not be used in the application, we want to make sure that the <code>handle()</code> method shows the correct behavior.</p> <p>Add a new <code>CapitalizeTitleMiddlewareTest.php</code> unit test in the <code>tests/Unit</code> directory. In this test, we'll assert that a title parameter on a <code>Request()</code> will contain the capitalized string after the middleware ran its <code>handle()</code> method:</p> tests/Unit/CapitalizeMiddlewareTest.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests\\Unit;\n\nuse Illuminate\\Http\\Request;\nuse JohnDoe\\BlogPackage\\Http\\Middleware\\CapitalizeTitle;\nuse JohnDoe\\BlogPackage\\Tests\\TestCase;\n\nclass CapitalizeTitleMiddlewareTest extends TestCase\n{\n    /** @test */\n    function it_capitalizes_the_request_title()\n    {\n        // Given we have a request\n        $request = new Request();\n\n        // with  a non-capitalized 'title' parameter\n        $request-&gt;merge(['title' =&gt; 'some title']);\n\n        // when we pass the request to this middleware,\n        // it should've capitalized the title\n        (new CapitalizeTitle())-&gt;handle($request, function ($request) {\n            $this-&gt;assertEquals('Some title', $request-&gt;title);\n        });\n    }\n}\n</code></pre>","tags":["Middleware","Before Middlware","After Middleware","Route Middleware","Middleware Groups","Global Middleware","Testing Middleware"]},{"location":"11-middleware/#after-middleware","title":"After Middleware","text":"<p>The \"after middleware\" acts on the response returned after passing through all other middleware layers down the chain. Next, it modifies, and returns the response. Generally, it takes the following form:</p> <pre><code>&lt;?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\n\nclass AfterMiddleware\n{\n    public function handle($request, Closure $next)\n    {\n        $response = $next($request);\n\n        // Perform action\n\n        return $response;\n    }\n}\n</code></pre>","tags":["Middleware","Before Middlware","After Middleware","Route Middleware","Middleware Groups","Global Middleware","Testing Middleware"]},{"location":"11-middleware/#testing-after-middleware","title":"Testing After Middleware","text":"<p>Similar to before middleware, we can unit test after middleware that operate on the <code>Response</code> for a given request and modify this request before it is passed down to the next layer of middleware. Given that we have an <code>InjectHelloWorld</code> middleware that injects the string 'Hello World' in each response, the following test would assert correct behavior:</p> tests/Unit/InjectHelloWorldMiddlewareTest.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests\\Unit;\n\nuse Illuminate\\Http\\Request;\nuse JohnDoe\\BlogPackage\\Http\\Middleware\\InjectHelloWorld;\nuse JohnDoe\\BlogPackage\\Tests\\TestCase;\n\nclass InjectHelloWorldMiddlewareTest extends TestCase\n{\n    /** @test */\n    function it_checks_for_a_hello_word_in_response()\n    {\n        // Given we have a request\n        $request = new Request();\n\n        // when we pass the request to this middleware,\n        // the response should contain 'Hello World'\n        $response = (new InjectHelloWorld())-&gt;handle($request, function ($request) { });\n\n        $this-&gt;assertStringContainsString('Hello World', $response);\n    }\n}\n</code></pre> <p>Now that we know the <code>handle()</code> method does its job correctly, let's look at the two options to register the middleware: globally vs. route specific.</p>","tags":["Middleware","Before Middlware","After Middleware","Route Middleware","Middleware Groups","Global Middleware","Testing Middleware"]},{"location":"11-middleware/#global-middleware","title":"Global middleware","text":"<p>Global middleware is, as the name implies, globally applied. Each request will pass through these middlewares.</p> <p>If we want our capitalization check example to be applied globally, we can append this middleware to the <code>Http\\Kernel</code> from our package's service provider. Make sure to import the Http Kernel contract, not the Console Kernel contract:</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nuse Illuminate\\Contracts\\Http\\Kernel;\nuse JohnDoe\\BlogPackage\\Http\\Middleware\\CapitalizeTitle;\n\npublic function boot(Kernel $kernel)\n{\n  // other things ...\n\n  $kernel-&gt;pushMiddleware(CapitalizeTitle::class);\n}\n</code></pre> <p>This will push our middleware into the application's array of globally registered middleware.</p>","tags":["Middleware","Before Middlware","After Middleware","Route Middleware","Middleware Groups","Global Middleware","Testing Middleware"]},{"location":"11-middleware/#route-middleware","title":"Route middleware","text":"<p>In our case, you might argue that we likely don't have a 'title' parameter on each request. Probably even only on requests that are related to creating/updating posts. On top of that, we likely only ever want to apply this middleware to requests related to our blog posts.</p> <p>However, our example middleware will modify all requests which have a title attribute. This is probably not desired. The solution is to make the middleware route-specific.</p> <p>Therefore, we can register an alias to this middleware in the resolved Router class, from within the <code>boot()</code> method of our service provider.</p> <p>Here's how to register the <code>capitalize</code> alias for this middleware:</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nuse Illuminate\\Routing\\Router;\nuse JohnDoe\\BlogPackage\\Http\\Middleware\\CapitalizeTitle;\n\npublic function boot()\n{\n  // other things ...\n\n  $router = $this-&gt;app-&gt;make(Router::class);\n  $router-&gt;aliasMiddleware('capitalize', CapitalizeTitle::class);\n}\n</code></pre> <p>We can apply this middleware from within our controller by requiring it from the constructor:</p> src/Http/Controllers/PostController.php<pre><code>&lt;?php\n\nclass PostController extends Controller\n{\n    public function __construct()\n    {\n        $this-&gt;middleware('capitalize');\n    }\n\n    // other methods... (will use this middleware)\n}\n</code></pre>","tags":["Middleware","Before Middlware","After Middleware","Route Middleware","Middleware Groups","Global Middleware","Testing Middleware"]},{"location":"11-middleware/#middleware-groups","title":"Middleware Groups","text":"<p>Additionally, we can push our middleware to certain groups, like <code>web</code> or <code>api</code>, to make sure our middleware is applied on each route that belongs to these groups.</p> <p>To do so, tell the router to push the middleware to a specific group (in this example, <code>web</code>):</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nuse Illuminate\\Contracts\\Http\\Kernel;\nuse JohnDoe\\BlogPackage\\Http\\Middleware\\CapitalizeTitle;\n\npublic function boot(Kernel $kernel)\n{\n  // other things ...\n\n  $kernel-&gt;prependMiddlewareToGroup('web', CapitalizeTitle::class); // Add it before all other middlewares\n  $kernel-&gt;appendMiddlewareToGroup('web', CapitalizeTitle::class); // Add it after all other middlewares\n}\n</code></pre> <p>The route middleware groups of a Laravel application are located in the <code>App\\Http\\Kernel</code> class. When applying this approach, you need to be sure that this package's users have the specific middleware group defined in their application.</p>","tags":["Middleware","Before Middlware","After Middleware","Route Middleware","Middleware Groups","Global Middleware","Testing Middleware"]},{"location":"11-middleware/#feature-testing-middleware","title":"Feature Testing Middleware","text":"<p>Regardless of whether we registered the middleware globally or route specifically, we can test that the middleware is applied when making a request.</p> <p>Add a new test to the <code>CreatePostTest</code> feature test, in which we'll assume our non-capitalized title will be capitalized after the request has been made.</p> tests/Feature/CreatePostTest.php<pre><code>&lt;?php\n\n/** @test */\nfunction creating_a_post_will_capitalize_the_title()\n{\n    $author = User::factory()-&gt;create();\n\n    $this-&gt;actingAs($author)-&gt;post(route('posts.store'), [\n        'title' =&gt; 'some title that was not capitalized',\n        'body' =&gt; 'A valid body',\n    ]);\n\n    $post = Post::first();\n\n    // 'New: ' was added by our event listener\n    $this-&gt;assertEquals('New: Some title that was not capitalized', $post-&gt;title);\n}\n</code></pre> <p>With the tests returning green, we've covered adding Middleware to your package.</p>","tags":["Middleware","Before Middlware","After Middleware","Route Middleware","Middleware Groups","Global Middleware","Testing Middleware"]},{"location":"12-mail/","title":"Mail","text":"<p>Using e-mails in your package works very much the same as in a normal Laravel application. However, in your package, you need to make sure you are loading a <code>views</code> directory from your package (or the end-user's exported version of it).</p> <p>To start sending e-mails, we need to create 1) a new mailable and 2) an e-mail template.</p> <p>The e-mail template can be in either markdown or blade template format, as you're used to. In this example, we'll focus on writing a Blade template, however if you're using a markdown template replace the <code>$this-&gt;view('blogpackage::mails.welcome')</code> with a call to <code>$this-&gt;markdown('blogpackage::mails.welcome')</code>. Notice that we're using the namespaced view name, allowing our package users to export the views and update their contents.</p>","tags":["Mail","Mail template","Views","Mailables","Testing Mail"]},{"location":"12-mail/#creating-a-mailable","title":"Creating a Mailable","text":"<p>First, add a new <code>Mail</code> folder in the <code>src/</code> directory, which will contain your mailables. Let's call it <code>WelcomeMail.php</code> mailable. Since we've been working with a <code>Post</code> model in the previous sections, let's accept that model in the constructor and assign it to a public <code>$post</code> property on the mailable.</p> src/Mail/WelcomeMail.php<pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Mail;\n\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Mail\\Mailable;\nuse Illuminate\\Queue\\SerializesModels;\nuse JohnDoe\\BlogPackage\\Models\\Post;\n\nclass WelcomeMail extends Mailable\n{\n    use Queueable, SerializesModels;\n\n    public $post;\n\n    public function __construct(Post $post)\n    {\n        $this-&gt;post = $post;\n    }\n\n    public function build()\n    {\n        return $this-&gt;view('blogpackage::emails.welcome');\n    }\n}\n</code></pre>","tags":["Mail","Mail template","Views","Mailables","Testing Mail"]},{"location":"12-mail/#registering-the-views-directory","title":"Registering the Views Directory","text":"<p>In the call to the mailable's <code>view()</code> method we've specified the string <code>emails.welcome</code>, which Laravel will translate to searching for a <code>welcome.blade.php</code> file in the <code>emails</code> directory in the package's registered views directory.</p> <p>To specify a view directory, you need to add the <code>$this-&gt;loadViews()</code> call to your package's service provider in the <code>boot()</code> method. View files can be referenced by the specified namespace, in this example, 'blogpackage'. Note: if you're following along since the section about Routing, you've already done this.</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\npublic function boot()\n{\n  // ... other things\n  $this-&gt;loadViewsFrom(__DIR__.'/../resources/views', 'blogpackage');\n}\n</code></pre> <p>This will look for views in the <code>resources/views</code> directory in the root of your package.</p>","tags":["Mail","Mail template","Views","Mailables","Testing Mail"]},{"location":"12-mail/#creating-a-blade-mail-template","title":"Creating a Blade Mail Template","text":"<p>Create the <code>welcome.blade.php</code> file in the <code>resources/views/emails</code> directory, where the <code>$post</code> variable will be freely available to use in the template.</p> resources/views/emails/welcome.blade.php<pre><code>&lt;p&gt;\nDear reader,\n\nPost title: {{ $post-&gt;title }}\n\n-- Sent from the blogpackage\n&lt;/p&gt;\n</code></pre>","tags":["Mail","Mail template","Views","Mailables","Testing Mail"]},{"location":"12-mail/#testing-mailing","title":"Testing Mailing","text":"<p>To test that e-mailing works and the mail contains all the right information, Laravel's Mail facade offers a built-in <code>fake()</code> method which makes it easy to swap the real mailer for a mock in our tests.</p> <p>To demonstrate how to test our e-mail, create a new <code>WelcomeMailTest</code> in the <code>tests/unit</code> directory. Next, in the test:</p> <ul> <li>Switch the Mail implementation for a mock using <code>Mail::fake()</code>.</li> <li>Create a <code>Post</code> using our factory (see section Models and Migrations).</li> <li>Assert that at this stage, no e-mails are sent using <code>assertNothingSent()</code>.</li> <li>Send a new <code>WelcomeMail</code> mailable, passing in the <code>Post</code> model.</li> <li>Assert that the e-mail was sent and contains the correct <code>Post</code> model using <code>assertSent()</code>.</li> </ul> <pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests\\Unit;\n\nuse Illuminate\\Support\\Facades\\Mail;\nuse JohnDoe\\BlogPackage\\Mail\\WelcomeMail;\nuse JohnDoe\\BlogPackage\\Models\\Post;\nuse JohnDoe\\BlogPackage\\Tests\\TestCase;\n\nclass WelcomeMailTest extends TestCase\n{\n    /** @test */\n    public function it_sends_a_welcome_email()\n    {\n        Mail::fake();\n\n        $post = Post::factory()-&gt;create(['title' =&gt; 'Fake Title']);\n\n        Mail::assertNothingSent();\n\n        Mail::to('test@example.com')-&gt;send(new WelcomeMail($post));\n\n        Mail::assertSent(WelcomeMail::class, function ($mail) use ($post) {\n            return $mail-&gt;post-&gt;id === $post-&gt;id\n                &amp;&amp; $mail-&gt;post-&gt;title === 'Fake Title';\n        });\n    }\n}\n</code></pre> <p>With this passing test, you can be sure that your package can now send e-mails.</p>","tags":["Mail","Mail template","Views","Mailables","Testing Mail"]},{"location":"13-jobs/","title":"Jobs","text":"<p>Much like the Mail facade in the previous section, implementing Jobs in your package is very similar to the workflow you'd go through in a Laravel application.</p>","tags":["Jobs","Dispatching Jobs","Testing Jobs","Bus Facade"]},{"location":"13-jobs/#creating-a-job","title":"Creating a Job","text":"<p>First, create a new <code>Jobs</code> directory in the <code>src/</code> directory of your package and add a <code>PublishPost.php</code> file, responsible for updating the 'published_at' timestamp of a <code>Post</code>. The example below illustrates what the <code>handle()</code> method could look like:</p> <pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Jobs;\n\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\nuse JohnDoe\\BlogPackage\\Models\\Post;\n\nclass PublishPost implements ShouldQueue\n{\n    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n\n    public $post;\n\n    public function __construct(Post $post)\n    {\n        $this-&gt;post = $post;\n    }\n\n    public function handle()\n    {\n        $this-&gt;post-&gt;publish();\n    }\n}\n</code></pre>","tags":["Jobs","Dispatching Jobs","Testing Jobs","Bus Facade"]},{"location":"13-jobs/#testing-dispatching-a-job","title":"Testing Dispatching a Job","text":"<p>For this example, we have a <code>publish()</code> method on the <code>Post</code> model, which is already under test (a unit test for <code>Post</code>). We can easily test the expected behavior by adding a new <code>PublishPostTest.php</code> unit test in the <code>tests/unit</code> directory.</p> <p>In this test, we can make use of the <code>Bus</code> facade, which offers a <code>fake()</code> helper to swap the real implementation with a mock. After dispatching the Job, we can assert on the <code>Bus</code> facade that our Job was dispatched and contains the correct <code>Post</code>.</p> <pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests\\Unit;\n\nuse Illuminate\\Support\\Facades\\Bus;\nuse JohnDoe\\BlogPackage\\Jobs\\PublishPost;\nuse JohnDoe\\BlogPackage\\Models\\Post;\nuse JohnDoe\\BlogPackage\\Tests\\TestCase;\n\nclass PublishPostTest extends TestCase\n{\n    /** @test */\n    public function it_publishes_a_post()\n    {\n        Bus::fake();\n\n        $post = Post::factory()-&gt;create();\n\n        $this-&gt;assertNull($post-&gt;published_at);\n\n        PublishPost::dispatch($post);\n\n        Bus::assertDispatched(PublishPost::class, function ($job) use ($post) {\n            return $job-&gt;post-&gt;id === $post-&gt;id;\n        });\n    }\n}\n</code></pre> <p>As the test passes, you can safely make use of this Job in the package.</p>","tags":["Jobs","Dispatching Jobs","Testing Jobs","Bus Facade"]},{"location":"14-notifications/","title":"Notifications","text":"<p>Notifications are a powerful tool in Laravel's toolbox. They provide support for sending notifications to an array of different services, including mail, SMS, Slack, or storing them in your database to show on the user's profile page, for example.</p>","tags":["Notifications","Testing Notifications","Custom Notification Channels"]},{"location":"14-notifications/#creating-a-notification","title":"Creating a Notification","text":"<p>First, to start using Notifications in your package, create a <code>Notifications</code> directory in your package's <code>src/</code> directory.</p> <p>For this example, add a <code>PostWasPublishedNotification.php</code>, which notifies the author of the <code>Post</code> that his submission was approved.</p> <pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Notifications;\n\nuse Illuminate\\Notifications\\Messages\\MailMessage;\nuse Illuminate\\Notifications\\Notification;\nuse JohnDoe\\BlogPackage\\Models\\Post;\n\nclass PostWasPublishedNotification extends Notification\n{\n    public $post;\n\n    public function __construct(Post $post)\n    {\n        $this-&gt;post = $post;\n    }\n\n    /**\n     * Get the notification's delivery channels.\n     *\n     * @param  mixed  $notifiable\n     * @return array\n     */\n    public function via($notifiable)\n    {\n        return ['mail'];\n    }\n\n    /**\n     * Get the mail representation of the notification.\n     *\n     * @param  mixed  $notifiable\n     * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n     */\n    public function toMail($notifiable)\n    {\n        return (new MailMessage)\n            -&gt;line(\"Your post '{$this-&gt;post-&gt;title}' was accepted\")\n            -&gt;action('Notification Action', url(\"/posts/{$this-&gt;post-&gt;id}\"))\n            -&gt;line('Thank you for using our application!');\n    }\n\n    /**\n     * Get the array representation of the notification.\n     *\n     * @param  mixed  $notifiable\n     * @return array\n     */\n    public function toArray($notifiable)\n    {\n        return [\n            //\n        ];\n    }\n}\n</code></pre>","tags":["Notifications","Testing Notifications","Custom Notification Channels"]},{"location":"14-notifications/#testing-notifications","title":"Testing Notifications","text":"<p>In the test:</p> <ul> <li>Swap the <code>Notification</code> facade with a mock using the <code>fake()</code> helper.</li> <li>Assert no notifications have been sent before calling the <code>notify()</code> method.</li> <li>Notify the <code>User</code> model via <code>$user-&gt;notify()</code> (which needs to use the <code>Notifiable</code> trait).</li> <li>Assert that the notification was sent and contains the correct <code>Post</code> model.</li> </ul> <pre><code>&lt;?php\n\nnamespace JohnDoe\\BlogPackage\\Tests\\Unit;\n\nuse Illuminate\\Support\\Facades\\Notification;\nuse JohnDoe\\BlogPackage\\Models\\Post;\nuse JohnDoe\\BlogPackage\\Notifications\\PostWasPublishedNotification;\nuse JohnDoe\\BlogPackage\\Tests\\TestCase;\nuse JohnDoe\\BlogPackage\\Tests\\User;\n\nclass NotifyPostWasPublishedTest extends TestCase\n{\n    /** @test */\n    public function it_can_notify_a_user_that_a_post_was_published()\n    {\n        Notification::fake();\n\n        $post = Post::factory()-&gt;create();\n\n        // the User model has the 'Notifiable' trait\n        $user = User::factory()-&gt;create();\n\n        Notification::assertNothingSent();\n\n        $user-&gt;notify(new PostWasPublishedNotification($post));\n\n        Notification::assertSentTo(\n            $user,\n            PostWasPublishedNotification::class,\n            function ($notification) use ($post) {\n                return $notification-&gt;post-&gt;id === $post-&gt;id;\n            }\n        );\n    }\n}\n</code></pre> <p>With the test passing, you can safely use this notification in your package.</p>","tags":["Notifications","Testing Notifications","Custom Notification Channels"]},{"location":"14-notifications/#custom-notification-channels","title":"Custom Notification Channels","text":"<p>Additionally, you may configure the channels for the notification to be dependent on your package's configuration file to allow your users to specify which notification channels they want to use.</p> <pre><code>&lt;?php\n\npublic function via($notifiable)\n{\n    return config('blogpackage.notifications.channels');\n}\n</code></pre> <p>Finally, add the <code>notifications.channels</code> sub-array entries to your configuration stub file (see the Package Configuration section).</p>","tags":["Notifications","Testing Notifications","Custom Notification Channels"]},{"location":"15-publishing/","title":"Publishing","text":"<p>Once satisfied with its functionality, you might want to share your package with a broader audience. This section will explain how to publish your package to the Packagist repository.</p> <p>If you haven't already pushed your local git repository to a repository host (GitHub / GitLab / BitBucket / etc.), you should do so now. It is advisable to create an online repository with the same (package) name as defined in your <code>composer.json</code> file. Try to match these names, for example, by renaming your package to follow this convention.</p> <p>Given the example below, consumers would be able to require the package using <code>composer require johndoe/blogpackage</code> and find the corresponding repository at (if using GitHub) <code>github.com/johndoe/blogpackage</code>.</p> composer.json<pre><code>{\n  \"name\": \"johndoe/blogpackage\",\n  \"description\": \"A demo package\",\n  ...\n}\n</code></pre> <p>The next step is to publish the git repository of the package to Packagist.</p>","tags":["Publishing","Packagist","Composer","Semantic Versioning"]},{"location":"15-publishing/#publishing-on-packagist","title":"Publishing on Packagist","text":"<p>To submit a package to Packagist, first create an account and then use the Submit link and specify the public <code>repository URL</code> to the git repository of your package.</p> <p>Packagist will now host a so-called <code>dev-master</code> version of your package. Although anyone can access this package now through <code>composer require [vendor]/[package-name]</code>, the consumer will receive the package in its current state on the <code>master</code> branch. This means that all changes to <code>master</code> immediately take effect when consumers run <code>composer update</code>, which might lead to breaking changes. For projects which define a <code>minimum-stability</code> of \"stable\", this means that Composer will not install your package at all.</p> <p>To prevent introducing breaking changes, while still free to refactor our package, the convention of semantic versioning is used to discriminate between versions and thus compatibility.</p>","tags":["Publishing","Packagist","Composer","Semantic Versioning"]},{"location":"15-publishing/#releasing-v100","title":"Releasing v1.0.0","text":"<p>Releases (and thus versions) of your package are tracked through tags on the corresponding git repository. There is currently a <code>dev-master</code> release available through Packagist, which always points to the latest commit on the <code>master</code> branch of the repository. However, ideally, we would like to serve the package in a fixed state to the consumer. This is where tags come in, which point to a specific commit.</p> <p>To release version <code>1.0.0</code> of the package, create a new tag in your git repository. If you're using GitHub, you can visit the \"releases\" tab and \"Create a new release\". Provide a \"Tag version\" and \"Release title\" of <code>1.0.0</code> targeted at the current state of the <code>master</code> branch (serving as a pointer to the latest commit). Additionally, you might provide information regarding this release in the description. After clicking \"Publish release\", Packagist will automatically update and reflect this new version. By default, consumers requiring the package without specifying a version will be served the latest tag/version/release which in this case will be <code>1.0.0</code>. You'll notice when you require this package in your project, the version constraint in <code>composer.json</code> will be <code>^1.0</code>, allowing <code>composer update</code> to download versions up to <code>1.x</code> (allowing minor and patch releases) but not <code>2.x</code> (major release, containing breaking changes). See the section below on semantic versioning for more information.</p>","tags":["Publishing","Packagist","Composer","Semantic Versioning"]},{"location":"15-publishing/#releasing-a-new-version","title":"Releasing a New Version","text":"<p>As you make updates to your package, refer to the semantic versioning while drafting new releases. When you create a new tag in the associated git repository, Packagist will automatically be updated.</p>","tags":["Publishing","Packagist","Composer","Semantic Versioning"]},{"location":"15-publishing/#semantic-versioning","title":"Semantic Versioning","text":"<p>This section will provide a short overview of how Semantic Versioning is used and applied by Composer. To get a more in-depth overview, check out semver.org.</p> <p>A version consists of three parts: <code>MAJOR.MINOR.PATCH</code>. Version <code>1.2.3</code> of a package could be referred to as a package on major version <code>1</code>, minor version <code>2</code>, patchlevel <code>3</code>.</p> <ul> <li> <p>Major: contains breaking changes, compared to the previous release. Consumers of our package need to make adjustments to their existing code integrating this package.</p> </li> <li> <p>Minor: contains added functionality (e.g. new methods) which do not break existing functionality. Consumers of our package do not need to make adjustments to their existing code integrating this package.</p> </li> <li> <p>Patchlevel: contains bug fixes, upgraded dependencies, etc. but does not contain new functionality. Consumers of our package do not need to make adjustments to their existing code integrating this package.</p> </li> </ul>","tags":["Publishing","Packagist","Composer","Semantic Versioning"]},{"location":"15-publishing/#composer","title":"Composer","text":"<p>PHP's package manager Composer uses the <code>composer.json</code> file to identify which packages should be installed and additionally which versions of a package are compatible with the project it belongs to. It keeps track of the versions through the package's tags on the corresponding repository.</p> <p>From the Composer documentation:</p> <p>Composer first asks the VCS to list all available tags, then creates an internal list of available versions based on these tags [...] When Composer has a complete list of available versions from your VCS, it then finds the highest version that matches all version constraints in your project (it's possible that other packages require more specific versions of the library than you do, so the version it chooses may not always be the highest available version) and it downloads a zip archive of that tag to unpack in the correct location in your vendor directory.</p>","tags":["Publishing","Packagist","Composer","Semantic Versioning"]},{"location":"15-publishing/#version-constraints","title":"Version Constraints","text":"<p>Composer supports various version constraints, of which the ones using semantic versioning are the most used as most packages implement semantic versioning. There are two distinct ways to define a semantic version range:</p> <ul> <li> <p>Semantic version range (tilde \"~\"): <code>~1.2</code>, translates to <code>&gt;=1.2 &lt;2.0.0</code>. All packages of version <code>1.x</code> are considered valid. A more specific range <code>~1.2.3</code> translates to <code>&gt;=1.2.3 &lt;1.3.0</code>. All packages of version <code>1.2.x</code> are considered valid.</p> </li> <li> <p>Strict semantic version range (caret \"^\"): <code>^1.2.3</code>, translates to <code>&gt;=1.2.3 &lt;2.0.0</code>. All packages of version <code>1.x</code> are considered valid (since no breaking changes should be introduced while upgrading minor versions) and is, therefore, closer following the semantic versioning system compared to the \"tilde\" method mentioned above.</p> </li> </ul> <p>Semantic versioning allows us to specify a broad range of compatible libraries, preventing collisions with other dependencies requiring the same library and avoiding breaking changes at the same time.</p> <p>Alternatively, Composer allows for more strict constraints:</p> <ul> <li> <p>Exact version: <code>1.2.3</code>, will always download <code>1.2.3</code>. If other packages require a different version of this dependency, Composer will throw an error since this dependency's requirements can not be satisfied.</p> </li> <li> <p>Defined version range (hyphen \"-\"): <code>1.0 - 2.0</code>, translates to <code>&gt;=1.0.0 &lt;2.1</code>. All packages of version <code>1.x</code> are considered valid. A more specific range could be defined in the form <code>1.0.0 - 1.3.0</code>, which translates to <code>&gt;=1.0.0 &lt;=1.3.0</code>. All packages of version <code>1.2.x</code> will be considered valid.</p> </li> </ul>","tags":["Publishing","Packagist","Composer","Semantic Versioning"]},{"location":"16-assets/","title":"Assets","text":"<p>You'll likely want to include a CSS and javascript file when you're adding views to your package.</p>","tags":["Assets","Vite"]},{"location":"16-assets/#creating-an-assets-directory","title":"Creating an 'assets' Directory","text":"<p>If you want to use a CSS stylesheet or include a javascript file in your views, create an <code>assets</code> directory in the <code>resources/</code> folder. Since we might include several stylesheets or javascript files, let's create two subfolders: <code>css</code> and <code>js</code> to store these files, respectively. A convention is to name the main javascript file <code>app.js</code> and the main stylesheet <code>app.css</code>.</p>","tags":["Assets","Vite"]},{"location":"16-assets/#customizable-assets","title":"Customizable Assets","text":"<p>Just like the views, we can let our users customize the assets if they want. First, we'll determine where we'll export the assets in the <code>boot()</code> method of our service provider under the 'assets' key in a 'blogpackage' directory in the public path of the end user's Laravel app:</p> BlogPackageServiceProvider.php<pre><code>&lt;?php\n\nif ($this-&gt;app-&gt;runningInConsole()) {\n  // Publish assets\n  $this-&gt;publishes([\n    __DIR__.'/../resources/assets' =&gt; public_path('blogpackage'),\n  ], 'assets');\n\n}\n</code></pre> <p>The assets can then be exported by users of our package using:</p> <pre><code>php artisan vendor:publish --provider=\"JohnDoe\\BlogPackage\\BlogPackageServiceProvider\" --tag=\"assets\"\n</code></pre>","tags":["Assets","Vite"]},{"location":"16-assets/#referencing-assets","title":"Referencing Assets","text":"<p>We can reference the stylesheet and javascript file in our views as follows:</p> <pre><code>&lt;script src=\"{{ asset('blogpackage/js/app.js') }}\"&gt;&lt;/script&gt;\n&lt;link href=\"{{ asset('blogpackage/css/app.css') }}\" rel=\"stylesheet\" /&gt;\n</code></pre>","tags":["Assets","Vite"]},{"location":"16-assets/#vite-config-to-build-the-package-assets","title":"Vite config to build the package assets","text":"<p>Sometimes we want to build the assets using a bundler like Webpack or Vite.</p> <p>The latest versions of Laravel switched from Webpack to Vite, and it would be nice to use the same bundler for the package to support all the hot reload and dev features of Vite.</p> <p>To do that we need to add Javascript packages using NPM.</p> <ol> <li>If you don't have a package.json file already, run the <code>npm init -y</code> command to create one.</li> <li>Install Vite and the laravel plugin <code>npm install -D vite laravel-vite-plugin</code>.</li> <li>Create the same structure for the resources as a Laravel website.</li> <li>Then create a vite.config.js</li> </ol> <p>vite.config.js file content</p> <pre><code>import { defineConfig } from 'vite';\nimport laravel from 'laravel-vite-plugin';\n\nexport default defineConfig({\n  plugins: [\n    laravel({\n      hotFile: 'public/vendor/blogpackage/blogpackage.hot', // Most important lines\n      buildDirectory: 'vendor/blogpackage', // Most important lines\n      input: ['resources/css/app.css', 'resources/js/app.js'],\n      refresh: true,\n    }),\n  ],\n});\n</code></pre> <p>package.json</p> <pre><code>{\n  \"private\": true,\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\"\n  },\n  \"devDependencies\": {\n    \"laravel-vite-plugin\": \"^0.7.8\",\n    \"vite\": \"^4.3.9\"\n  }\n}\n</code></pre> <p>Then you can use it like this in a blade template.</p> <pre><code>{{ Vite::useHotFile('vendor/blogpackage/blogpackage.hot')\n        -&gt;useBuildDirectory(\"vendor/blogpackage\")\n        -&gt;withEntryPoints(['resources/css/app.css', 'resources/js/app.js']) }}\n</code></pre> <p>This will then let us use the Vite dev server in a local project when developing the package. We can also build the assets using Vite for production.</p> <p>For development, we will need to create a symlink of the public/vendor/blogpackage folder</p> <p>Example of a symlink command <code>mklink /J .\\public\\vendor\\blogpackage .\\vendor\\johndoe\\blogpackage\\public\\vendor\\blogpackage</code></p> <p>And start the dev server of both projects, the laravel app and the package.</p> <p>For production, we will need to publish the assets</p> <p>Add this to your ServiceProvider</p> <pre><code>$this-&gt;publishes([\n    __DIR__.'/../public/vendor/blogpackage' =&gt; public_path('vendor/blogpackage'),\n], 'assets');\n</code></pre>","tags":["Assets","Vite"]},{"location":"history/","title":"History of LaravelPackage.com","text":"<p>Work on the LaravelPackage.com project started in October 2019. Since then the project became the go-to documentation on Laravel package development with more than 400 stars on GitHub. There has been a vivid community of contributors within the open source / Laravel community.</p>","tags":["package basics","directory structure","autoloading","composer"]},{"location":"history/#original-creator","title":"Original creator","text":"<p>This project is originally created by John Braun. John is an avid developer with a strong sense of giving back to the community. His website is located at https://johnbraun.nl, and he can be found on Twitter: @jhnbrn90. Definitely go check them out if you want to learn something new!</p> <p>We want to thank John Braun for his contributions to the open source / Laravel package community. This resource would not have been here without these commitments.</p>","tags":["package basics","directory structure","autoloading","composer"]},{"location":"history/#current-maintainer","title":"Current maintainer","text":"<p>Currently, the project is maintained by the PackagePages organisation which can be found here: https://packagepages.dev/. PackagePages is a project which consists of a free to use SaaS application for open source developers, a blog and this documentation site.  They can be found here: </p> <ul> <li> <p>https://packagepages.dev/</p> </li> <li> <p>https://blog.packagepages.dev/</p> </li> <li> <p>https://laravelpackage.com/</p> </li> </ul>","tags":["package basics","directory structure","autoloading","composer"]},{"location":"supporting-new-laravel-versions/laravel-11/","title":"Laravel 11","text":"","tags":["laravel","laravel 11"]},{"location":"supporting-new-laravel-versions/laravel-11/#update","title":"Update","text":"<p>Laravel 11 is here and in full effect, check if your project / package gives the green light using this tool by Shift:  https://laravelshift.com/can-i-upgrade-laravel.</p>","tags":["laravel","laravel 11"]},{"location":"supporting-new-laravel-versions/laravel-11/#before-release","title":"Before release","text":"<p>Laravel 11 is here the corner as of writing this guide (23 feb 2024)! We hope you are as excited as we are. Supporting laravel 11 is probably going to be very easy for you as a package maintainer and should only take 30 minutes max! We wrote down some of the important to know things and show you how you support this new release.</p>","tags":["laravel","laravel 11"]},{"location":"supporting-new-laravel-versions/laravel-11/#important-items-from-the-upgrade-guide","title":"Important items from the upgrade guide","text":"<p>Please read the full upgrade guide as many of the changes are very specific but the biggest ones we will highlight in the next sections. See full guide here: https://laravel.com/docs/master/upgrade</p>","tags":["laravel","laravel 11"]},{"location":"supporting-new-laravel-versions/laravel-11/#php-82-requirement","title":"PHP 8.2 requirement","text":"<p>Laravel 11 requires php 8.2 which allows for some new features, check them out here: https://www.php.net/releases/8.2/en.php Be aware that you probably want to continue supporting older versions of laravel / php as laravel itself does.  At the time of writing the laravel team support laravel 10 ( php 8.1 - 8.3 ) and laravel 11 ( php 8.2 - 8.3 ).</p>","tags":["laravel","laravel 11"]},{"location":"supporting-new-laravel-versions/laravel-11/#removal-of-config-directory-for-new-projects","title":"Removal of config directory for new projects","text":"<p>Laravel 11 ships with a new skeleton which removes the config directory, if your package supports a config then dont be worried.  The existing config directory is not going away but you might have to let users know that they can generate the config directory using the following command: <code>php artisan config:publish</code></p>","tags":["laravel","laravel 11"]},{"location":"supporting-new-laravel-versions/laravel-11/#testing-if-your-package-is-ready","title":"Testing if your package is ready","text":"<p>Your package is probably hosted on GitHub which has GitHub Actions, using the following example github action runner file you can test if your package is ready / supports laravel 11 and other versions. <pre><code>name: run-tests\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: true\n      matrix:\n        os: [ ubuntu-latest ]\n        php: [ 8.1, 8.2 ]\n        laravel: [ 9.*, 10.*, 11.* ]\n        stability: [ prefer-stable ]\n        include:\n          - laravel: 9.*\n            testbench: ^7.0\n          - laravel: 10.*\n            testbench: ^8.0\n          - laravel: 11.*\n            testbench: ^9.0\n        exclude:\n          - laravel: 10.*\n            php: 8.0\n          - laravel: 11.*\n            php: 8.1\n\n    name: PHP${{ matrix.php }} - LARAVEL${{ matrix.laravel }} - ${{ matrix.stability }} - ${{ matrix.os }}\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Setup PHP\n        uses: shivammathur/setup-php@v2\n        with:\n          php-version: ${{ matrix.php }}\n          extensions: dom, curl, libxml, mbstring, zip, pcntl, pdo, sqlite, pdo_sqlite, bcmath, soap, intl, gd, exif, iconv, imagick, fileinfo\n          coverage: none\n\n      - name: Setup problem matchers\n        run: |\n          echo \"::add-matcher::${{ runner.tool_cache }}/php.json\"\n          echo \"::add-matcher::${{ runner.tool_cache }}/phpunit.json\"\n      - name: Install dependencies\n        run: |\n          composer require \"laravel/framework:${{ matrix.laravel }}\" \"orchestra/testbench:${{ matrix.testbench }}\" --no-interaction --no-update\n          composer update --${{ matrix.stability }} --prefer-dist --no-interaction\n      - name: Execute tests\n        run: vendor/bin/phpunit\n</code></pre></p>","tags":["laravel","laravel 11"]},{"location":"supporting-new-laravel-versions/laravel-11/#community-feedback","title":"Community feedback","text":"<p>As you might have seen on Twitter/X or Reddit people are excited to play around with the new laravel 11 release. To make sure your package helps them enjoy it we recommend updating your package before laravel 11 releases. </p>","tags":["laravel","laravel 11"]}]}